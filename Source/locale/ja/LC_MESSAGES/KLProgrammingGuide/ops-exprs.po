#
msgid ""
msgstr ""
"Project-Id-Version: Fabric Engine 2.0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-10-06 18:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:4
msgid "Operators and Expressions"
msgstr "演算子・式"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:6
msgid ""
"This chapter explains the possible operators and resulting expressions in "
"KL.  Generally, KL has the same operator and expression syntax as JavaScript"
" and C, and in particular follows exactly the same precedence and "
"associativity rules."
msgstr ""
"この章では、KLでの受付可能な演算子、結果とし生じる式について説明します。一般的にKLは "
"JavaScript、C言語と同じ演算子と式についての文法をもち、特に優先順位と結合規則は全く同一です。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:11
msgid "Operators"
msgstr "演算子"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:13
msgid ""
"KL supports the same basic set of operators as JavaScript and C.  These "
"operations are broadly categorized as :ref:`arithmetic operators "
"<arithmetic-ops>`, :ref:`logical operators <logical-ops>`, :ref:`bitwise "
"operators <bitwise-ops>` and :ref:`assignment operators <ass-ops>`."
msgstr ""
"KLは、JavaScriptやC言語と同様の基本的な演算子を持ちます。おおまかに分類すると  :ref:`算術演算子 <arithmetic-ops>`, "
":ref:`論理演算子 <logical-ops>`, :ref:`ビット演算子 <bitwise-ops>` and :ref:`代入演算子 "
"<ass-ops>` です。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:18
msgid "Arithmetic Operators"
msgstr "算術演算子"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:21
msgid "Add and Subtract"
msgstr "加算・減算"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:23
msgid ""
"When ``+`` or ``-`` appear between two expressions they are referred to as "
"the :dfn:`add` and :dfn:`subtract` binary operators.  These operators are "
"pre-defined for all integer and floating point types, where they perform the"
" usual arithmetic operations, but they can also be overloaded to apply to "
"user-defined structures or different combinations of types.  For example, it"
" is possible to define an operator that takes a user-defined ``Rect`` on the"
" left and a user-defined ``Point`` on the right."
msgstr ""
"``+`` もしくは ``-`` を２つの式の間に置くと、加算（ :dfn:`add` ）、減算（ :dfn:`subtract` "
"）２項演算子として扱います。これらの演算子は、全ての整数、浮動小数点数型に組み込みで定義され、通常の算術演算を実行します。ユーザ定義の、構造体あるいは他の型"
"の組み合わせに対し、演算子のオーバーロードを適用することも可能です。例えば、左項にユーザ定義の ``Rect`` 、右項に ``Point`` "
"をとるようなある演算子を定義することが可能です。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:25
msgid ""
"In addition to being pre-defined for integer and floating-point types, the "
"``+`` (add) operator (but not the ``-`` (subtract) operator) is defined for "
"the ``String`` type; the result of adding two strings is the two strings "
"concatenated together."
msgstr ""
"``+`` 加算演算子 ( ``-`` 減算演算子ではなく)は、 整数・浮動小数点数型の組み込み定義されたものに加え、文字列型にも定義されています。２つの文"
"字列を加算すると、２つの文字列を連結します。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:28
msgid "Multiply, Divide and Remainder"
msgstr "乗算・除算、剰余"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:30
msgid ""
"When ``*``, ``/`` or ``%`` appear between two expressions they are referred "
"to as the :dfn:`multiply`, :dfn:`divide` and :dfn:`remainder` binary "
"operators.  These operators are pre-defined for all integer and floating "
"point types, where they perform the usual arithmetic operations, but they "
"can also be overloaded to apply to user-defined structures or different "
"combinations of types.  For example, it is possible to define a multiply "
"operator that takes a ``Float32`` on the left and a user-defined ``Vec3`` on"
" the right."
msgstr ""
"``*``, ``/``, ``%`` を２つの式の間に置くと、乗算、除算、剰余（ :dfn:`multiply`, :dfn:`divide` and "
":dfn:`remainder` ）２項演算子として扱います。これらの演算子は全ての整数・浮動小数点数型について組み込み定義され、通常の算術演算を行います。"
"ユーザ定義の、構造体あるいは他の型の組み合わせに対し、演算子のオーバーロードを適用することも可能です。例えば、左項にユーザ定義の ``Float32`` "
"、右項に ``Vec3`` をとるようなある演算子を定義することが可能です。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:33
msgid "Unary Plus and Minus"
msgstr "単項のプラス・マイナス"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:35
msgid ""
"When ``+`` or ``-`` appears in front of an integer or floating-point "
"expression without an expression to the left they are referred to as the "
":dfn:`unary plus` and :dfn:`unary minus` operators.  The unary plus operator"
" doesn't do anything to the value it operates on, but the unary minus "
"operator returns the value that, when added to the original, produces zero "
"(for unsigned integer expressions); for signed integer and floating-point "
"expressions, this is value of the expression with its sign reversed."
msgstr ""
"``+`` または ``-`` 演算子を、整数・浮動小数点数式の直前に左辺になにも式を置かずおくと、 :dfn:`unary plus` 、 "
":dfn:`unary minus` 演算子として扱います。単項プラス演算子は値に対して何も作用しませんが、単項マイナス演算子は、符号なし整数式の場合:0、"
"符号付き整数および符号付き浮動小数点数の場合:符号を反転させた値、を生成します。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:38
msgid "Increment and Decrement Operators"
msgstr "インクリメント・デクリメント演算子"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:40
msgid ""
"The ``++`` (increment) and ``--`` (decrement) operators can be used to add "
"one to or subtract one from a variable.  These operators have the following "
"properties:"
msgstr ""
"``++`` (インクリメント)、 ``--`` （デクリメント）演算子は、変数のひとつ加算、減算に用います。これらの演算子は以下の特徴があります。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:42
msgid ""
"The operators only work on variables or input-output parameters; then cannot"
" operate on constants or input parameters.  This is because they change the "
"value of the expression."
msgstr ""
"変数、もしくは入出力パラメータ（io parameter）のみに使用可能です。式の値を変更するため定数や入力パラメータ（input "
"parameter）は操作できません。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:44
msgid "They only operate on integer values."
msgstr "整数値のみ操作できます。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:46
msgid ""
"Each operator can appear either *precede* or *follow* the variable it "
"operates on.  When it precedes the variable, the value of the expression is "
"the value of the variable *after* incrementing; this is referred to as a "
"*prefix* increment (or decrement).  When it follows the variable, the result"
" is the value of the variable *before* incrementing; this is referred to as "
"a *postfix* increment (or decrement)."
msgstr ""
"どの演算子も、変数に対し前置あるいは後置のどちらでも作用します。前置する場合、式の値は変数のインクリメント *後* の値となります。これは "
"*prefix* インクリメント（デクリメント）と呼ばれます。後置する場合、式の値は変数のインクリメント *前* の値となります。これは "
"*postfix* インクリメント（デクリメント）と呼ばれます。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:48
msgid "They cannot be overloaded."
msgstr "オーバーロード不可能です。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:53
msgid "Logical Operators"
msgstr "論理演算子"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:58
msgid "Equality Operators"
msgstr "等価演算子（Equality Operators）"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:60
msgid ""
"When ``==`` or ``!=`` appear between two expressions they are referred to as"
" the :dfn:`equal-to` or :dfn:`not-equal-to` binary operators, respectively; "
"collectively, they are referred to as the :dfn:`equality operators`."
msgstr ""
"``==`` あるいは ``!=`` を２つの式の間におくと、 :dfn:`equal-to` あるいは :dfn:`not-equal-to` "
"2項演算子として扱います。2つまとめて等価演算子（ :dfn:`equality operators` ）と呼びます。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:62
msgid ""
"The equality operators are pre-defined for all integer and floating-point "
"types as well as the ``Boolean`` and ``String`` types.  They can also be "
"overloaded to apply to user-defined structure and specific object types or "
"combinations of different types."
msgstr ""
"等価演算子は、全ての整数・浮動小数点数型、 ``Boolean`` 、 ``String`` "
"型について組み込み定義されています。ユーザ定義の構造体や、特定のオブジェクト、型のコンビネーションに対してオーバーロードが可能です。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:67
msgid "Identity Operators"
msgstr "同一性演算子（Identity Operators）"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:69
msgid ""
"When ``===`` or ``!==`` appear between two expressions they are referred to "
"as the :dfn:`identical-to` or :dfn:`not-identical-to` binary operators, "
"respectively; collectively, they are referred to as the :dfn:`identity "
"operators`."
msgstr ""
"``===`` あるいは ``!==`` を２つの式の間に置くと、 :dfn:`identical-to` あるいは "
":dfn:`not-identical-to` 2項演算子として扱います。２つまとめて同一性演算子 :dfn:`identity operators` "
"と呼びます。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:71
msgid ""
"The identity operators are pre-defined only for :ref:`object types "
"<KLPG.types.objects>` and :ref:`interface types <KLPG.types.interfaces>`.  "
"They test whether two objects or interfaces refer to the same object, ie. "
"whether changing one will change the other."
msgstr ""
"同一性演算子は、 :ref:`object 型 <KLPG.types.objects>` と :ref:`interface types "
"<KLPG.types.interfaces>` 型のみに事前定義されています。２つのオブジェクト（もしくはインタフェース）が同じオブジェクトを参照するか "
"―つまり片方への変更がもう片方にも作用するかどうかをテストします。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:76
msgid "Relational Operators"
msgstr "関係演算子（Relational Operators）"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:78
msgid ""
"When ``<``, ``<=``, ``>`` or ``>=`` appear between two expressions they are "
"referred to as the :dfn:`less-than`, :dfn:`less-than-or-equal-to`, :dfn"
":`greater-than` or :dfn:`greater-than-or-equal-to` binary operators, "
"respectively; collectively, they are referred to as the :dfn:`relational "
"operators`."
msgstr ""
"``<``, ``<=``, ``>`` or ``>=`` を２つの式の間に置くと、:dfn:`less-than`, "
":dfn:`less-than-or-equal-to`, :dfn:`greater-than`, "
":dfn:`greater-than-or-equal-to` ２項演算子として扱います。まとめて関係演算子と呼びます。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:80
msgid ""
"The relational operators are pre-defined for all integer and floating-point "
"types as well as the ``String`` type.  They can also be overloaded to apply "
"to user-defined structure types or combinations of different types."
msgstr ""
"関係演算子は、全ての整数・浮動小数点数、文字列型に対し事前定義されています。ユーザ定義の構造体、型のコンビネーションに対してオーバーロードが可能です。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:83
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:261
msgid "Logical AND"
msgstr "論理 AND"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:85
msgid ""
"When ``&&`` appears between two expressions it is referred to as the "
":dfn:`logical AND` binary operator.  Logical AND operates as follows: the "
"left operand is cast to a ``Boolean`` (ie. a ``Boolean`` value is "
"constructed from the left hand operand).  If the result is ``true``, the "
"result is the right operand, otherwise the result is the left operand."
msgstr ""
"``&&`` を２つの式の間におくと、 :dfn:`logical AND` として扱います。論理AND 演算子は以下のように振る舞います。左オペランドを "
"``Boolean`` にキャストし ``true`` であれば、 演算子の結果は右オペランド、 ``false`` "
"であれば結果は左オペランド。（左オペランドをキャストするということはつまり、左オペラントより ``Boolean`` "
"の値がコンストラクトされるということです）"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:87
msgid ""
"The behavior of logical AND is the same as in JavaScript but different than "
"C.  In C, the result value of a logical AND is always an integer (bool in "
"C++)."
msgstr "論理AND の動作はJavaScriptと同じですが、C言語とは異なります。Cでは、論理ANDの結果は常に整数です。（C++ では bool）"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:89
msgid ""
"It is not possible to overload the logical AND operator.  However, you can "
"\"enable\" it for custom types (structures) by creating a ``Boolean`` "
"constructor with a single parameter whose type is the type of the left "
"operand."
msgstr ""
"論理AND 演算子のオーバロードは不可能です。ただし、カスタム型（構造体）に対し、 ``Boolean`` "
"コンストラクタを作成し、そのコンストラクタを左オペラントの型と同じ型をパラメータを１つとるように定義することで、論理AND を有効にすることはできます。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:92
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:263
msgid "Logical OR"
msgstr "論理 OR"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:94
msgid ""
"When ``||`` appears between two expressions it is referred to as the "
":dfn:`logical OR` binary operator.  Logical OR operates as follows: the left"
" operand is cast to a ``Boolean`` (ie. a ``Boolean`` value is constructed "
"from the left hand operand).  If the result is ``true``, the result is the "
"left operand, otherwise the result is the right operand."
msgstr ""
"``||``  を２つの式の間におくと、 :dfn:`logical OR` として扱います。論理 OR 演算子は以下のように振る舞います。左オペランドを "
"``Boolean`` にキャストし ``true`` であれば、 演算子の結果は左オペランド、 ``false`` "
"であれば結果は右オペランド。（左オペランドをキャストするということはつまり、左オペラントより ``Boolean`` "
"の値がコンストラクトされるということです）"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:96
msgid ""
"The behavior of logical OR is the same as in JavaScript but different than "
"C.  In C, the result value of a logical AND is always an integer (bool in "
"C++)."
msgstr "論理OR の動作はJavaScriptと同じですが、C言語とは異なります。Cでは、論理ORの結果は常に整数です。（C++ では bool）"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:98
msgid ""
"It is not possible to overload the logical OR operator.  However, you can "
"\"enable\" it for custom types (structures) by creating a ``Boolean`` "
"constructor with a single parameter whose type is the type of the left "
"operand."
msgstr ""
"論理OR 演算子のオーバロードは不可能です。ただし、カスタム型（構造体）に対し、 ``Boolean`` "
"コンストラクタを作成し、そのコンストラクタを左オペラントの型と同じ型をパラメータを１つとるように定義することで、論理OR を有効にすることはできます。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:101
msgid "Logical NOT"
msgstr "論理 NOT"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:103
msgid ""
"When ``!`` (exclamation mark) appears in front of an expression it is "
"referred to as the :dfn:`logical NOT` unary operator.  Logical NOT inverts "
"the logical value of expression; more specifically, it constructs a new "
"``Boolean`` value from the expression and then inverts its logical value.  "
"Therefore, logical not can be applied to any expression that has a "
"``Boolean`` constructor that takes a single parameter whose types is the "
"type of the expression."
msgstr ""
"``!`` （エクスクラメーションびっくりマーク）を式の前につけると、論理NOT :dfn:`logical NOT` "
"単項演算子として扱います。論理NOTは式の論理値を反転させます。具体的な挙動は、まず式から新たな ``Boolean`` "
"値をコンストラクトし、その論理値を反転します。したがって論理NOTは、式の型がそのパラメータの型と同じ、単一のパラメータをとる ``Boolean`` "
"コンストラクタを持つどのような式にも使用可能です。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:105
msgid ""
"It is not possible to overload the logical NOT operator.  However, you can "
"\"enable\" it for custom types (structures) by creating a ``Boolean`` "
"constructor with a single parameter whose type is the structure."
msgstr ""
"論理NOT 演算子のオーバロードは不可能です。ただし、カスタム型（構造体）に対し、 ``Boolean`` "
"コンストラクタを作成し、そのコンストラクタを左オペラントの型と同じ型をパラメータを１つとるように定義することで、論理NOT を有効にすることはできます。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:108
msgid "The Conditional Operator"
msgstr "条件演算子"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:110
msgid ""
"When three expressions are separated by ``?`` (question mark) and ``:`` "
"(colon) it is referred to as the :dfn:`conditional operator` (or "
":dfn:`ternary operator`).  The conditional operator constructs a ``Boolean``"
" from the first operand; if it has value ``true``, the result is the second "
"operand, otherwise it is the third."
msgstr ""
"３つの式を、 ``?`` （感嘆符）と ``:`` （コロン) により分割すると、条件演算子 :dfn:`conditional operator` "
"(あるいは３項演算子 :dfn:`ternary operator`) として扱います。３項演算子は１つめのオペランドより ``Boolean`` "
"をコンストラクト、その値が ``true`` であれば２番めのオペランド、 ``false`` であれば３番めのオペランドが結果となります。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:112
msgid "It is not possible to overload the conditional operator."
msgstr "３項演算子をオーバーロードすることはできません。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:115
msgid "The Comma Operator"
msgstr "コンマ演算子"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:117
msgid ""
"When two expressions are separated by ``,`` (comma) it is referred to as the"
" :dfn:`comma operator`).  The comma operator first evaluates the left-hand "
"expression, throwing away the result, and then evaluates the right-hand "
"expression.  The value of the right-hand expression is the value of the "
"comma operator expression."
msgstr ""
"``,`` (コンマ)により２つの式を分割すると、コンマ演算子 :dfn:`comma operator` "
"として扱います。コンマ演算子は、最初に左側の式を評価し、結果を捨て、右側の式を評価します。右側の式の値がこの演算子の式の値となります。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:119
msgid "It is not possible to overload the comma operator."
msgstr "コンマ演算子をオーバーロードすることはできません。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:124
msgid "Bitwise Operators"
msgstr "ビット演算子"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:127
msgid "Bitwise AND, OR and XOR"
msgstr "ビット AND・OR・XOR"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:129
msgid ""
"When ``&``, ``|`` or ``^`` appear between two expressions they are referred "
"to as :dfn:`bitwise AND`, :dfn:`bitwise OR` or :dfn:`bitwise XOR` binary "
"operators, respectively."
msgstr ""
"``&``, ``|``,  ``^`` を２つの式の間に置くと、それぞれ :dfn:`bitwise AND`, :dfn:`bitwise OR`, "
":dfn:`bitwise XOR` として扱います。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:131
msgid ""
"Bitwise AND, OR and XOR are predefined for all integer types; they perform "
"the usual bitwise operation on the two values.  They are also predefined for"
" the ``Boolean`` type, which is treated as if it was a single bit with value"
" 1 (if true) or 0 (if false)."
msgstr ""
"ビット AND・OR・XOR は全ての整数型に事前定義されています。２つの値における通常のビット演算を行います。 ``Boolean`` "
"型にも事前定義されています。どちらも単一ビット 1 (true) あるいは 0 (false)であるかのように扱われます。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:133
msgid ""
"Bitwise AND, OR and XOR can be overloaded for user-defined structures or "
"combinations of different types."
msgstr "ビット AND・OR・XOR はユーザ定義の構造体、型のコンビネーションに対しオーバーロード不可能です。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:136
msgid "Bitwise NOT"
msgstr "ビットNOT"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:138
msgid ""
"When ``~`` (tilde) appears in front of an expression it is referred to as "
"the :dfn:`bitwise NOT` unary operator."
msgstr "``~`` (チルダ)を式の前に置くと、ビット NOT :dfn:`bitwise NOT` 単項演算子として扱います。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:140
msgid ""
"Bitwise NOT is predefined for all integer types; it inverts the state of the"
" bits of the value.  It is also predefined for the ``Boolean`` type, which "
"is treated as if it was a single bit with value 1 (if true) or 0 (if false)."
msgstr ""
"ビット NOTは、全ての整数型に事前定義されています。。値のビット状態を反転させます。 ``Boolean`` "
"型にも事前定義されています。どちらも単一ビット 1 (true) あるいは 0 (false)であるかのように扱われます。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:143
msgid "Left and Right Shift"
msgstr "左・右シフト"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:145
msgid ""
"When ``<<`` or ``>>`` appear between two expressions they are referred to as"
" the :dfn:`left shift` or :dfn:`right shift` binary operators, respectively."
"  These operators are pre-defined for all integer types, where they perform "
"a left or right bit shift of the left operand by the number of bits given in"
" the right operand."
msgstr ""
"``<<`` もしくは ``>>`` を２つの式の間に置くと、 :dfn:`left shift` もしくは :dfn:`right shift` "
"２項演算子として扱います。全ての整数型に事前定義されています。左側のオペランドを右側のオペランドに与えられたビット数によって、左・右ビットシフト行います。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:147
msgid ""
"A right-shift of a signed integer value will fill the left most bits with "
"the sign bit, not with zeros.  Right shifts of unsigned integer values and "
"left shifts of any integer values always fill with zeros."
msgstr ""
"符号付き整数の値の右シフトは、左端のビットを符号ビットで埋めます。0ではありません。符号なし整数の値の右シフト、そして符号ありなし両方の整数の左シフトは、常"
"に0で埋まります。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:149
msgid ""
"It is possible to overload the shift operators for user-defined types, and "
"even provide non-integer types as right-hand operands."
msgstr "シフト演算子はユーザ定義の型、さらに整数型以外のものでも、右側オペランドとしてオーバロードが可能です。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:154
msgid "Assignment Operators"
msgstr "代入演算子"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:157
msgid "Direct Assignment Operator"
msgstr "直接代入演算子"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:159
msgid ""
"When ``=`` appears between two expressions it is referred to as the "
":dfn:`direct assignment operator`.  The direct assignment operator is "
"predefined for all types; see :ref:`KLPG.types` for details on how direct "
"assignment operates for a given type.  It is also possible to overload the "
"direct assignment operator for any type. See :ref:`overloading-direct-ass-"
"op`"
msgstr ""
"``=`` 演算子を2つの式の間に置くと、直接代入演算子 :dfn:`direct assignment operator` "
"として扱います。直接代入演算子は全ての型で事前定義されています。 :ref:`KLPG.types` "
"により詳しい代入の仕組みを参照してください。どのような型でもこの演算子のオーバロードが可能です。 "
":ref:`overloading-direct-ass-op` 参照"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:162
msgid "Compound Assignment Operators"
msgstr "複合代入演算子"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:164
msgid ""
"Any of the arithmetic or bitwise (but not logical) binary operators can be "
"combined with ``=`` to form a :dfn:`compound assignment operator`; these are"
" specifically ``+=``, ``-=``, ``*=``, ``/=``, ``%=``, ``<<=``, ``>>=``, "
"``&=``, ``^=`` and ``|=``."
msgstr ""
"どのような算術、ビット（論理演算子は含めない）２項演算子も、 ``=`` と組み合わせて複合代入演算子  :dfn:`compound "
"assignment operator` とすることができます。具体的には ``+=``, ``-=``, ``*=``, ``/=``, ``%=``, "
"``<<=``, ``>>=``, ``&=``, ``^=`` and ``|=``"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:166
msgid ""
"A compound assignment operator is predefined for a given type if and only if"
" the corresponding binary operator is predefined for the type.  It is also "
"possible to overload the compound assignment operator for any type, and it "
"is even possible to have different types for the left and right operands. "
"See :ref:`overloading-compound-ass-ops`."
msgstr ""
"複合代入演算子は、その型に対して事前定義されている２項演算子であれば、事前定義されています。複号代入演算子はオーバーロード可能です。左オペランドと右オペラン"
"ドの型が違う場合でも可能です。 :ref:`overloading-compound-ass-ops` を参照してください。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:169
msgid "Operators and Polymorphism"
msgstr "演算子と多態性（Operators and Polymorphism）"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:171
msgid ""
"Operator invocations are subject to the same rules as function calls with "
"respect to polymorphism.  If an exact match for an operator with the "
"parameter types equal to the operand types is not found, KL will find the "
"best-match among the existing implementations of the operator.  This makes "
"it possible, for instance, to add an integer and a string; the result is "
"that the integer is cast to a string and then the strings are concatenated."
msgstr ""
"演算子・オペレータの呼び出しは多態性に関して、関数呼び出しにおけるそれと同じルールが適用されます。あるオペレータが以下の条件 "
"―そのオペレータのパラメータの型とオペランドの型が厳密に一致しない場合、KLはそのオペレータの既存の実装の中から最適なものを探します。これにより例えば、整数"
"と文字列を加算える事ができます。つまり、まず整数が文字列へとキャストされます。その文字列と文字列が連結されます。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:173
msgid ""
"For more information on polymorphism and best-match rules, see "
":ref:`polymorphism`."
msgstr "多態についてと、最適なもの探索ルールについてのさらなる情報は :ref:`polymorphism` を参照してください。"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:176
msgid "Expressions"
msgstr "式（Expressions）"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:178
msgid ""
"There are two types of expressions in KL: simple expressions and compound "
"expressions."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:183
msgid "Simple Expressions"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:185
msgid ""
":dfn:`Simple expressions` are the expressions from which more complex "
"expressions are derived.  The simple expressions are:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:187
msgid ""
"Symbols that refer to variables, function arguments or constants.  The type "
"of the expression is the type of the entity referred to.  Examples: ``foo``,"
" ``myParam``, ``mathPI``.  See :ref:`scope` for how symbol names are "
"resolved."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:189
msgid ""
"Boolean, integer, floating-point and string constants.  The type of the "
"expression is the type of the constant.  Examples: ``true``, ``42``, "
"``3.14159``, ``FILE``, ``LINE``.  See :ref:`literal-constants`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:192
msgid "Compound Expressions"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:194
msgid ""
":dfn:`Compound expressions` are built from :ref:`simple expressions <simple-"
"exprs>` and/or other compound expressions using :ref:`operators <ops>`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:196
msgid ""
"The following table lists all the different compound expressions in KL.  "
"Compound expressions are grouped by :dfn:`type`; all expressions of the same"
" type are of the same precedence and share the same associativity.  Compound"
" expression types are listed from highest to lowest precedence."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:199
msgid "Type"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:199
msgid "Associativity"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:199
msgid "Expression(s)"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:201
msgid "Postfix"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:201
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:225
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:231
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:235
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:239
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:247
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:255
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:257
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:259
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:261
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:263
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:289
msgid "left-to-right"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:201
msgid ":samp:`{functionName}({args})`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:203
msgid ":samp:`{expr}[{expr}]`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:205
msgid ":samp:`{expr}.{member}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:207
msgid ":samp:`{expr}.{method}({args})`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:209
msgid ":samp:`{expr}++`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:211
msgid ":samp:`{expr}--`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:213
msgid "Prefix"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:213
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:265
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:267
msgid "right-to-left"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:213
msgid ":samp:`+{expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:215
msgid ":samp:`-{expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:217
msgid ":samp:`++{expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:219
msgid ":samp:`--{expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:221
msgid ":samp:`!{expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:223
msgid ":samp:`~{expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:225
msgid "Multiplicative"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:225
msgid ":samp:`{expr} * {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:227
msgid ":samp:`{expr} / {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:229
msgid ":samp:`{expr} % {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:231
msgid "Additive"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:231
msgid ":samp:`{expr} + {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:233
msgid ":samp:`{expr} - {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:235
msgid "Shift"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:235
msgid ":samp:`{expr} << {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:237
msgid ":samp:`{expr} >> {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:239
msgid "Relational"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:239
msgid ":samp:`{expr} < {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:241
msgid ":samp:`{expr} <= {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:243
msgid ":samp:`{expr} > {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:245
msgid ":samp:`{expr} >= {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:247
msgid "Equality Identity"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:247
msgid ":samp:`{expr} == {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:249
msgid ":samp:`{expr} != {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:251
msgid ":samp:`{expr} === {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:253
msgid ":samp:`{expr} !== {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:255
msgid "Bitwise AND"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:255
msgid ":samp:`{expr} & {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:257
msgid "Bitwise XOR"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:257
msgid ":samp:`{expr} ^ {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:259
msgid "Bitwise OR"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:259
msgid ":samp:`{expr} | {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:261
msgid ":samp:`{expr} && {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:263
msgid ":samp:`{expr} || {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:265
msgid "Conditional"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:265
msgid ":samp:`{expr}? {expr}: {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:267
msgid "Assignment"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:267
msgid ":samp:`{expr} = {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:269
msgid ":samp:`{expr} += {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:271
msgid ":samp:`{expr} -= {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:273
msgid ":samp:`{expr} *= {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:275
msgid ":samp:`{expr} /= {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:277
msgid ":samp:`{expr} %= {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:279
msgid ":samp:`{expr} <<= {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:281
msgid ":samp:`{expr} >>= {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:283
msgid ":samp:`{expr} &= {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:285
msgid ":samp:`{expr} ^= {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:287
msgid ":samp:`{expr} |= {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:289
msgid "Comma"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:289
msgid ":samp:`{expr} , {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:293
msgid "Controlling Order of Operations"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:295
msgid ""
"The order of operations can be explicitly controlled by putting ``(`` and "
"``)`` (parentheses) around expressions."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:310
msgid "Scoping Rules"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:312
msgid ""
"The term :dfn:`scope` in programming languages refers to the parts of a "
"program in which variables, constants and functions are visible; the rules "
"that govern how scopes work are referred to as :dfn:`scoping rules`.  Scopes"
" are also responsible for managing the \"lifecycle\" of variables; in the "
"case of KL, this refers to when destructors are called for structure values."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:318
msgid "Types of Scopes"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:320
msgid ""
"In KL, there are four kinds scopes: the global scope, function scopes, "
"compound statement scopes and temporary scopes.  Scopes :dfn:`nest` inside "
"each other; when a KL program refers to a variable by name, the compiler "
"determines which variable is being referred to by searching from the current"
" innermost scope outwards through the nested scopes to the outermost scope "
"(which is always the global scope).  Like C, KL is a statically-scoped "
"language, meaning that the exact variable that is being referred to is "
"resolved at compile time (and not at run time)."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:326
msgid "The Global Scope"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:328
msgid ""
"The global scope is the top-level scope of a KL program.  The symbols that "
"are visible in the global scope are global constants as well as functions "
"and operators.  The global scope is always the outermost scope at any point "
"in a KL program."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:334
msgid "Function Scope"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:336
msgid ""
"Whenever a function or other function-list entity is defined, a function "
"scope is created that is nested inside the global scope.  The arguments to "
"the function are provided within the function scope.  Within the function "
"scope, a function definition also creates a compound statement scope "
"corresponding to the compound statement that constitutes the body of the "
"function."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:344
msgid "Compound Statement Scope"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:346
msgid ""
"Any time that a ``{`` followed by zero or more statements followed by ``}`` "
"is used to introduce a compound statement, a new :dfn:`compound statement "
"scope` is introduced.  Compound statement scopes are nested inside function "
"scopes (when they correspond to the compound statement that constitutes the "
"body of a function) or inside other compound statement scopes."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:348
msgid ""
"When control reaches the end of a compound statement (by executing the last "
"statement or via the ``return``, ``break`` or ``continue`` statements), any "
"structure values that have corresponding destructors will have those "
"destructors executed."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:350
msgid ""
"Note that declaring a loop index variable inside a loop statement is a "
"special case of a compound statement scope.  In the case that the loop body "
"is a compound statement, the corresponding compound statement scope is "
"nested inside the loop's compound statement scope."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:356
msgid "Temporary Scope"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:358
msgid ""
"Any time that a constructor is directly invoked to create a temporary value "
"(see :ref:`KLPG.constructor.invocation.temporary`), a scope is created to "
"contain the temporary value.  The scope encloses the surrounding expression "
"of the temporary value; this means that when the surrounding expression is "
"finished execution, the temporary value's destructor, if it exists, is "
"executed."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:361
msgid "Nested Scopes Example"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:363
msgid ""
"For a precise understanding of the nesting of KL scopes, study the following"
" example carefully."
msgstr ""
