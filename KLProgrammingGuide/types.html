<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>KLの型システム &mdash; Fabric Engine 2.0.0 Unofficial Documentation (ja)</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Fabric Engine 2.0.0 Unofficial Documentation (ja)" href="../index.html" />
    <link rel="up" title="KL プログラミングガイド" href="index.html" />
    <link rel="next" title="Functions and Other Global Declarations" href="globals.html" />
    <link rel="prev" title="KLの文法" href="syntax.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="globals.html" title="Functions and Other Global Declarations"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="syntax.html" title="KLの文法"
             accesskey="P">前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Fabric Engine 2.0.0 Unofficial Documentation (ja)</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">KL プログラミングガイド</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="the-kl-type-system">
<span id="klpg-types"></span><h1>KLの型システム<a class="headerlink" href="#the-kl-type-system" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>大部分の言語と異なり、KLは動的な型システム ―Fabricの環境から引き継ぐ を持ちます。複合型の登録は、多くの場合動的言語（例えば JavaScriptや Python）で実行されているFabric環境を通し行われます。これらの型は自動的にその実行環境においてKLプログラムから利用可能となります。ただし、このことは言語のセマンティクス（プログラム意味論）に影響をあたえるものではありません。つまりKLの型システムは依然として、純粋に、その言語自体の観点から説明できます。</p>
<p>多くの他のプログラミング言語同様にKLには、他の型へと継承できる定められた数の基本型だけでなく、異なる種の派生型の数々もサポートします。</p>
<div class="section" id="base-types">
<span id="index-0"></span><h2>基本型（Base Types）<a class="headerlink" href="#base-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>KLでの基本型は以下：</p>
<dl class="docutils">
<dt><code class="code docutils literal"><span class="pre">Boolean</span></code></dt>
<dd><p class="first last"><code class="code docutils literal"><span class="pre">true</span></code> もしくは <code class="code docutils literal"><span class="pre">false</span></code> のいずれかをとる</p>
</dd>
<dt><code class="docutils literal"><span class="pre">UInt8</span></code></dt>
<dd><p class="first last">8-bit 符号なし整数（unsigned integer）</p>
</dd>
<dt><code class="docutils literal"><span class="pre">Byte</span></code></dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">UInt8</span></code> のエイリアス（別名）</p>
</dd>
<dt><code class="docutils literal"><span class="pre">SInt8</span></code></dt>
<dd><p class="first last">8-bit 符号つき整数（signed integer）</p>
</dd>
<dt><code class="docutils literal"><span class="pre">UInt16</span></code></dt>
<dd><p class="first last">16-bit 符号なし整数</p>
</dd>
<dt><code class="docutils literal"><span class="pre">SInt16</span></code></dt>
<dd><p class="first last">16-bit 符号つき整数</p>
</dd>
<dt><code class="docutils literal"><span class="pre">UInt32</span></code></dt>
<dd><p class="first last">32-bit 符号なし整数</p>
</dd>
<dt><code class="docutils literal"><span class="pre">Count</span></code></dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">UInt32</span></code> へのエイリアス。基数を表すために使用される。</p>
</dd>
<dt><code class="docutils literal"><span class="pre">Index</span></code></dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">UInt32</span></code> へのエイリアス。序数を表すために使用される。</p>
</dd>
<dt><code class="docutils literal"><span class="pre">Size</span></code></dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">UInt32</span></code> へのエイリアス</p>
</dd>
<dt><code class="docutils literal"><span class="pre">SInt32</span></code></dt>
<dd><p class="first last">32-bit 符号つき整数</p>
</dd>
<dt><code class="docutils literal"><span class="pre">Integer</span></code></dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">SInt32</span></code> へのエイリアス</p>
</dd>
<dt><code class="docutils literal"><span class="pre">UInt64</span></code></dt>
<dd><p class="first last">64-bit 符号なし整数</p>
</dd>
<dt><code class="docutils literal"><span class="pre">DataSize</span></code></dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">UInt64</span></code> へのエイリアス。メモリブロックのサイズを表すために使用される</p>
</dd>
<dt><code class="docutils literal"><span class="pre">SInt64</span></code></dt>
<dd><p class="first last">64-bit 符号つき整数</p>
</dd>
<dt><code class="docutils literal"><span class="pre">Float32</span></code></dt>
<dd><p class="first last">32-bit IEEE浮動小数点数</p>
</dd>
<dt><code class="docutils literal"><span class="pre">Scalar</span></code></dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">Float32</span></code> へのエイリアス</p>
</dd>
<dt><code class="docutils literal"><span class="pre">Float64</span></code></dt>
<dd><p class="first last">64-bit IEEE浮動小数点数</p>
</dd>
<dt><code class="docutils literal"><span class="pre">String</span></code></dt>
<dd><p class="first last">ゼロ個以上の文字の連なり</p>
</dd>
</dl>
<div class="section" id="the-boolean-type">
<span id="index-1"></span><h3>論理型（ <code class="code docutils literal"><span class="pre">Boolean</span></code> Type）<a class="headerlink" href="#the-boolean-type" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="code docutils literal"><span class="pre">Boolean</span></code> 型の式の値は、論理真もしくは論理偽です。以下の特徴を持ちます：</p>
<ul class="simple">
<li><p class="first">定数 <code class="code docutils literal"><span class="pre">true</span></code> 及び <code class="code docutils literal"><span class="pre">false</span></code> はそれぞれ論理値である真、偽の <code class="code docutils literal"><span class="pre">Boolean</span></code> です。</p>
</li>
<li><p class="first">他の型から Boolean 型へのキャスト：</p>
<ul>
<li><p class="first">全整数型（例えば <code class="docutils literal"><span class="pre">UInt32</span></code>, <code class="docutils literal"><span class="pre">Byte</span></code>)は値が 0 ではない時のみ true となります。</p>
</li>
<li><p class="first">全浮動小数点数型（すなわち <code class="docutils literal"><span class="pre">Float32</span></code> and <code class="docutils literal"><span class="pre">Float64</span></code>）は値が  <code class="docutils literal"><span class="pre">0.0</span></code> もしくは <code class="docutils literal"><span class="pre">-0.0</span></code> と等しくない場合にのみ true となります。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">String</span></code> の値はその長さが 0以上 の場合のみ true となります。</p>
</li>
<li><p class="first">配列と辞書型はカラでない場合のみ true となります。</p>
</li>
<li><p class="first">構造体はそのままでは  <code class="code docutils literal"><span class="pre">Boolean</span></code> 型へキャストできません。キャスト可能にするには引数パラメータにキャストを行いたい構造体をとる <code class="code docutils literal"><span class="pre">Boolean</span></code> コンストラクタを実装します。 <a class="reference internal" href="globals.html#klpg-constructor"><span>Constructors</span></a> を参照してください。</p>
</li>
</ul>
</li>
<li><p class="first">演算子</p>
<ul>
<li><p class="first">算術演算子 (2項演算子 <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code>, <code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">/</span></code>, <code class="docutils literal"><span class="pre">%</span></code> だけでなく 単独の <code class="docutils literal"><span class="pre">-</span></code> and <code class="docutils literal"><span class="pre">+</span></code>) はいずれも <code class="code docutils literal"><span class="pre">Boolean</span></code> の値には無効です。</p>
</li>
<li><p class="first"><code class="code docutils literal"><span class="pre">Boolean</span></code> の値には比較演算子 <code class="docutils literal"><span class="pre">==</span></code> と <code class="docutils literal"><span class="pre">!=</span></code> のみ有効です。</p>
</li>
<li><p class="first">全2項論理演算子(<code class="docutils literal"><span class="pre">|</span></code>, <code class="docutils literal"><span class="pre">&amp;amp;</span></code>, <code class="docutils literal"><span class="pre">^</span></code> and <code class="docutils literal"><span class="pre">~</span></code>) は <code class="code docutils literal"><span class="pre">Boolean</span></code> 値で有効です。値を単一のビットであるかのように扱います。</p>
</li>
</ul>
</li>
</ul>
<p>以下に <code class="code docutils literal"><span class="pre">Boolean</span></code> 型の使用例を示します:</p>
<div class="highlight-python"><div class="highlight"><pre>operator entry() {
  Boolean a = true;
  report(a);
  Boolean b = a &amp; false;
  report(b);
  report(a != b);
}
</pre></div>
</div>
<p>出力:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">true</span>
<span class="n">false</span>
<span class="n">true</span>
</pre></div>
</div>
</div>
<div class="section" id="integer-types">
<span id="index-2"></span><h3>整数型（Integer Types）<a class="headerlink" href="#integer-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">UInt8</span></code>, <code class="docutils literal"><span class="pre">SInt8</span></code>, <code class="docutils literal"><span class="pre">UInt16</span></code>, <code class="docutils literal"><span class="pre">SInt16</span></code>, <code class="docutils literal"><span class="pre">UInt32</span></code>, <code class="docutils literal"><span class="pre">SInt32</span></code>, <code class="docutils literal"><span class="pre">UInt64</span></code>, <code class="docutils literal"><span class="pre">SInt64</span></code> 型、そしてエイリアス (<code class="docutils literal"><span class="pre">Byte</span></code>, <code class="docutils literal"><span class="pre">Integer</span></code>, <code class="docutils literal"><span class="pre">Size</span></code>, <code class="docutils literal"><span class="pre">Count</span></code>, <code class="docutils literal"><span class="pre">Index</span></code>, <code class="docutils literal"><span class="pre">DataSize</span></code>), は総称して <span class="target" id="index-28"></span>integer types として知られ、全ての整数を表現します。</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">UInt8</span></code></dt>
<dd><p class="first last">8-bit 符号なし整数（unsigned integer）</p>
</dd>
<dt><code class="docutils literal"><span class="pre">Byte</span></code></dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">UInt8</span></code> のエイリアス（別名）</p>
</dd>
<dt><code class="docutils literal"><span class="pre">SInt8</span></code></dt>
<dd><p class="first last">8-bit 符号つき整数（signed integer）</p>
</dd>
<dt><code class="docutils literal"><span class="pre">UInt16</span></code></dt>
<dd><p class="first last">16-bit 符号なし整数</p>
</dd>
<dt><code class="docutils literal"><span class="pre">SInt16</span></code></dt>
<dd><p class="first last">16-bit 符号つき整数</p>
</dd>
<dt><code class="docutils literal"><span class="pre">UInt32</span></code></dt>
<dd><p class="first last">32-bit 符号なし整数</p>
</dd>
<dt><code class="docutils literal"><span class="pre">SInt32</span></code></dt>
<dd><p class="first last">32-bit 符号つき整数</p>
</dd>
<dt><code class="docutils literal"><span class="pre">Integer</span></code></dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">SInt32</span></code> へのエイリアス</p>
</dd>
<dt><code class="docutils literal"><span class="pre">UInt64</span></code></dt>
<dd><p class="first last">64-bit 符号なし整数</p>
</dd>
<dt><code class="docutils literal"><span class="pre">SInt64</span></code></dt>
<dd><p class="first last">64-bit 符号つき整数</p>
</dd>
<dt><code class="docutils literal"><span class="pre">Count</span></code></dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">UInt32</span></code> へのエイリアス。通常 <code class="docutils literal"><span class="pre">Size</span></code> は配列中の要素の数量の数え上げにしようされる。</p>
</dd>
<dt><code class="docutils literal"><span class="pre">Index</span></code></dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">UInt32</span></code> へのエイリアス。通常  <code class="docutils literal"><span class="pre">Index</span></code> は配列のインデックスに使用される。</p>
</dd>
<dt><code class="docutils literal"><span class="pre">DataSize</span></code></dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">UInt64</span></code> へのエイリアス。メモリブロックのサイズを表すために使用され、 <code class="docutils literal"><span class="pre">dataSize</span></code> メッソドの返り値の型として使用される。</p>
</dd>
<dt><code class="docutils literal"><span class="pre">Size</span></code></dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">UInt32</span></code> へのエイリアス。</p>
</dd>
</dl>
<p>整数型の振る舞い：</p>
<ul class="simple">
<li><p class="first">全 <a class="reference internal" href="ops-exprs.html#arithmetic-ops"><span>arithmetic</span></a>, <a class="reference internal" href="ops-exprs.html#logical-ops"><span>logical</span></a>, <a class="reference internal" href="ops-exprs.html#bitwise-ops"><span>bitwise</span></a> 演算子は整数型に対し期待通り動作します。</p>
</li>
<li><p class="first">整数型の定数は <code class="docutils literal"><span class="pre">s32</span></code> が <code class="docutils literal"><span class="pre">SInt32</span></code>, <code class="docutils literal"><span class="pre">u64</span></code> が <code class="docutils literal"><span class="pre">UInt64</span></code>, などのように接尾語をともない型付けされます。接尾語を付さない場合、 <code class="docutils literal"><span class="pre">SInt32</span></code> となります。参照 <a class="reference internal" href="syntax.html#integer-constants"><span>整数定数</span></a>.</p>
</li>
</ul>
<p>整数型の使用例:</p>
<div class="highlight-python"><div class="highlight"><pre>operator entry() {
  Byte b = 64;
  report(b);
  Size s = 45 * Size(b) + 32;
  report(s);
  Integer i = -75 * Integer(s) + 18;
  report(i);
}
</pre></div>
</div>
<p>出力:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mi">64</span>
<span class="mi">2912</span>
<span class="o">-</span><span class="mi">218382</span>
</pre></div>
</div>
<div class="section" id="integer-atomic-methods">
<span id="index-4"></span><h4>整数型のアトミックメソッド<a class="headerlink" href="#integer-atomic-methods" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>整数型は組み込み <a class="reference internal" href="globals.html#methods"><span>Methods</span></a> を持ちます。整数型の値に対しアトミックな操作（不可分操作、atomic operation）をおこないます。アトミックな操作は、ロックフリーなアルゴリズムで実装されています。アトミックな操作については <a class="reference external" href="http://en.wikipedia.org/wiki/Linearizability">http://en.wikipedia.org/wiki/Linearizability</a> を参照してください。</p>
<dl class="function">
<dt>
<code class="descname">UInt8 UInt8.atomicAdd(UInt8 val)</code></dt>
<dt>
<code class="descname">SInt8 SInt8.atomicAdd(SInt8 val)</code></dt>
<dt>
<code class="descname">UInt16 UInt16.atomicAdd(UInt16 val)</code></dt>
<dt>
<code class="descname">SInt16 SInt16.atomicAdd(SInt16 val)</code></dt>
<dt>
<code class="descname">UInt32 UInt32.atomicAdd(UInt32 val)</code></dt>
<dt>
<code class="descname">SInt32 SInt32.atomicAdd(SInt32 val)</code></dt>
<dt>
<code class="descname">UInt64 UInt64.atomicAdd(UInt64 val)</code></dt>
<dt>
<code class="descname">SInt64 SInt64.atomicAdd(SInt64 val)</code></dt>
<dd><p>整数型の値にアトミックな加算</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメタ:</th><td class="field-body"><ul class="first simple">
<li><strong>val</strong> &#8211; 加算する値</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">戻り値:</th><td class="field-body"><p class="first last">操作前の古い整数型の値</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">UInt8 UInt8.atomicInc()</code></dt>
<dt>
<code class="descname">SInt8 SInt8.atomicInc()</code></dt>
<dt>
<code class="descname">UInt16 UInt16.atomicInc()</code></dt>
<dt>
<code class="descname">SInt16 SInt16.atomicInc()</code></dt>
<dt>
<code class="descname">UInt32 UInt32.atomicInc()</code></dt>
<dt>
<code class="descname">SInt32 SInt32.atomicInc()</code></dt>
<dt>
<code class="descname">UInt64 UInt64.atomicInc()</code></dt>
<dt>
<code class="descname">SInt64 SInt64.atomicInc()</code></dt>
<dd><p>整数型のアトミックなインクリメント</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">戻り値:</th><td class="field-body">操作前の古い整数型の値</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">UInt8 UInt8.atomicSub(UInt8 val)</code></dt>
<dt>
<code class="descname">SInt8 SInt8.atomicSub(SInt8 val)</code></dt>
<dt>
<code class="descname">UInt16 UInt16.atomicSub(UInt16 val)</code></dt>
<dt>
<code class="descname">SInt16 SInt16.atomicSub(SInt16 val)</code></dt>
<dt>
<code class="descname">UInt32 UInt32.atomicSub(UInt32 val)</code></dt>
<dt>
<code class="descname">SInt32 SInt32.atomicSub(SInt32 val)</code></dt>
<dt>
<code class="descname">UInt64 UInt64.atomicSub(UInt64 val)</code></dt>
<dt>
<code class="descname">SInt64 SInt64.atomicSub(SInt64 val)</code></dt>
<dd><p>整数型からアトミックな減算</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメタ:</th><td class="field-body"><ul class="first simple">
<li><strong>val</strong> &#8211; 加算する値</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">戻り値:</th><td class="field-body"><p class="first last">操作前の古い整数型の値</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">UInt8 UInt8.atomicDec()</code></dt>
<dt>
<code class="descname">SInt8 SInt8.atomicDec()</code></dt>
<dt>
<code class="descname">UInt16 UInt16.atomicDec()</code></dt>
<dt>
<code class="descname">SInt16 SInt16.atomicDec()</code></dt>
<dt>
<code class="descname">UInt32 UInt32.atomicDec()</code></dt>
<dt>
<code class="descname">SInt32 SInt32.atomicDec()</code></dt>
<dt>
<code class="descname">UInt64 UInt64.atomicDec()</code></dt>
<dt>
<code class="descname">SInt64 SInt64.atomicDec()</code></dt>
<dd><p>整数型のアトミックなデクリメント</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">戻り値:</th><td class="field-body">操作前の古い整数型の値</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">UInt8 UInt8.atomicOr(UInt8 val)</code></dt>
<dt>
<code class="descname">SInt8 SInt8.atomicOr(SInt8 val)</code></dt>
<dt>
<code class="descname">UInt16 UInt16.atomicOr(UInt16 val)</code></dt>
<dt>
<code class="descname">SInt16 SInt16.atomicOr(SInt16 val)</code></dt>
<dt>
<code class="descname">UInt32 UInt32.atomicOr(UInt32 val)</code></dt>
<dt>
<code class="descname">SInt32 SInt32.atomicOr(SInt32 val)</code></dt>
<dt>
<code class="descname">UInt64 UInt64.atomicOr(UInt64 val)</code></dt>
<dt>
<code class="descname">SInt64 SInt64.atomicOr(SInt64 val)</code></dt>
<dd><p>整数型のアトミックなビット演算「or」</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメタ:</th><td class="field-body"><ul class="first simple">
<li><strong>val</strong> &#8211; 「or」する整数型の値</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">戻り値:</th><td class="field-body"><p class="first last">操作前の古い整数型の値</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">UInt8 UInt8.atomicAnd(UInt8 val)</code></dt>
<dt>
<code class="descname">SInt8 SInt8.atomicAnd(SInt8 val)</code></dt>
<dt>
<code class="descname">UInt16 UInt16.atomicAnd(UInt16 val)</code></dt>
<dt>
<code class="descname">SInt16 SInt16.atomicAnd(SInt16 val)</code></dt>
<dt>
<code class="descname">UInt32 UInt32.atomicAnd(UInt32 val)</code></dt>
<dt>
<code class="descname">SInt32 SInt32.atomicAnd(SInt32 val)</code></dt>
<dt>
<code class="descname">UInt64 UInt64.atomicAnd(UInt64 val)</code></dt>
<dt>
<code class="descname">SInt64 SInt64.atomicAnd(SInt64 val)</code></dt>
<dd><p>整数型のアトミックなビット演算「and」</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメタ:</th><td class="field-body"><ul class="first simple">
<li><strong>val</strong> &#8211; 「and」する整数型の値</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">戻り値:</th><td class="field-body"><p class="first last">操作前の古い整数型の値</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">UInt8 UInt8.atomicXor(UInt8 val)</code></dt>
<dt>
<code class="descname">SInt8 SInt8.atomicXor(SInt8 val)</code></dt>
<dt>
<code class="descname">UInt16 UInt16.atomicXor(UInt16 val)</code></dt>
<dt>
<code class="descname">SInt16 SInt16.atomicXor(SInt16 val)</code></dt>
<dt>
<code class="descname">UInt32 UInt32.atomicXor(UInt32 val)</code></dt>
<dt>
<code class="descname">SInt32 SInt32.atomicXor(SInt32 val)</code></dt>
<dt>
<code class="descname">UInt64 UInt64.atomicXor(UInt64 val)</code></dt>
<dt>
<code class="descname">SInt64 SInt64.atomicXor(SInt64 val)</code></dt>
<dd><p>整数型のアトミックなビット演算「xor」</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメタ:</th><td class="field-body"><ul class="first simple">
<li><strong>val</strong> &#8211; 「xor」する整数型の値</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">戻り値:</th><td class="field-body"><p class="first last">操作前の古い整数型の値</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">UInt8 UInt8.atomicCAS(UInt8 oldVal, UInt8 newVal)</code></dt>
<dt>
<code class="descname">SInt8 SInt8.atomicCAS(SInt8 oldVal, SInt8 newVal)</code></dt>
<dt>
<code class="descname">UInt16 UInt16.atomicCAS(UInt16 oldVal, UInt16 newVal)</code></dt>
<dt>
<code class="descname">SInt16 SInt16.atomicCAS(SInt16 oldVal, SInt16 newVal)</code></dt>
<dt>
<code class="descname">UInt32 UInt32.atomicCAS(UInt32 oldVal, UInt32 newVal)</code></dt>
<dt>
<code class="descname">SInt32 SInt32.atomicCAS(SInt32 oldVal, SInt32 newVal)</code></dt>
<dt>
<code class="descname">UInt64 UInt64.atomicCAS(UInt64 oldVal, UInt64 newVal)</code></dt>
<dt>
<code class="descname">SInt64 SInt64.atomicCAS(SInt64 oldVal, SInt64 newVal)</code></dt>
<dd><p>アトミックな、compare-and-swap 操作を行います ―例えば、整数型の値 <code class="docutils literal"><span class="pre">oldVal</span></code> を <code class="docutils literal"><span class="pre">newVal</span></code> に変更し、値が変更された場合のみ <code class="docutils literal"><span class="pre">oldVal</span></code> を返します。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメタ:</th><td class="field-body"><ul class="first simple">
<li><strong>oldVal</strong> &#8211; 整数型と比較する値</li>
<li><strong>newVal</strong> &#8211; 整数型の値、比較が成功した場合に設定される</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">戻り値:</th><td class="field-body"><p class="first last">操作前の古い整数型の値</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="floating-point-types">
<span id="index-5"></span><h3>浮動小数点数型（Floating-Point Types）<a class="headerlink" href="#floating-point-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Float32</span></code> と <code class="docutils literal"><span class="pre">Float64</span></code> 型 ( <code class="docutils literal"><span class="pre">Float32</span></code> のエイリアスである <code class="docutils literal"><span class="pre">Scalar</span></code> も) は総称して浮動小数点数型（ <em class="dfn">floating-point types</em> ）として知られ、 <abbr>IEEE</abbr> 浮動小数点数を表現する。これらの型はビット幅が異なる：:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Float32</span></code></dt>
<dd><p class="first last">32-bit <abbr>IEEE</abbr> 浮動小数点数</p>
</dd>
<dt><code class="docutils literal"><span class="pre">Float64</span></code></dt>
<dd><p class="first last">64-bit <abbr>IEEE</abbr> 浮動小数点数</p>
</dd>
<dt><code class="docutils literal"><span class="pre">Scalar</span></code></dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">Float32</span></code> へのエイリアス</p>
</dd>
</dl>
<p>浮動小数点数型の振る舞い</p>
<ul class="simple">
<li><p class="first">浮動小数点数の定数は JavaScript や C言語と同じ文法を持ち、 <code class="docutils literal"><span class="pre">Float64</span></code> 型になる。詳細は  <a class="reference internal" href="syntax.html#floating-point-constants"><span>浮動小数点数定数</span></a> を参照。</p>
</li>
<li><p class="first">全算術演算子（ <a class="reference internal" href="ops-exprs.html#arithmetic-ops"><span>arithmetic</span></a> ）、論理演算子（ <a class="reference internal" href="ops-exprs.html#logical-ops"><span>logical</span></a> ）が浮動小数点数の値に対して使用できる。ビット演算子は使用不可能です。</p>
</li>
</ul>
<p>以下に浮動小数点数型の使用例を示します:</p>
<div class="highlight-python"><div class="highlight"><pre>operator entry() {
  Float32 x = 3.141;
  report(x);
  Float64 y = 2.718;
  report(y);
  Float32 z = x*x + y*y;
  report(z);
}
</pre></div>
</div>
<p>出力:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mf">3.141</span>
<span class="mf">2.718</span>
<span class="mf">17.2534</span>
</pre></div>
</div>
</div>
<div class="section" id="the-string-type">
<span id="index-6"></span><h3>文字列型（<code class="docutils literal"><span class="pre">String</span></code> Type）<a class="headerlink" href="#the-string-type" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">文字列</span></code> 型はテキスト文字列 ―すなわちゼロ個以上の文字の連なりを表します。 <code class="docutils literal"><span class="pre">文字列</span></code> 型の値は <span class="target" id="index-29"></span>string value として参照されます。</p>
<p><code class="docutils literal"><span class="pre">文字列</span></code> 型のセマンティクスの理解は重要です。文字列の特徴：</p>
<ul class="simple">
<li><p class="first">文字列とはゼロ個以上の文字の連なり</p>
</li>
<li><p class="first">文字列の長さは、 <code class="docutils literal"><span class="pre">Size</span></code> 型であり、最大長は <span class="math">\(2^{31}-1\)</span></p>
</li>
<li><p class="first">文字列定数はKLソースコード中にインライン指定可能です。JavaScript や Python 同様シングルクォーテーションもしくはダブルクォーテーションマークを使用します。文字列定数に関する詳細は <a class="reference internal" href="syntax.html#string-constants"><span>文字列定数</span></a> を参照してください。</p>
</li>
<li><p class="first">文字列は以下の操作とプロパティを持ちます。</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">.length</span></code> プロパティをもち、文字列中の文字数を返します。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">+=</span></code> 代入演算子により他の文字列を所定の文字列に追記します。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">+</span></code> 2項演算子を使用し、2つの文字列をつなぎ合わせ、新たな文字列を作成します。</p>
</li>
<li><p class="first">論理演算子 <code class="docutils literal"><span class="pre">==</span></code>, <code class="docutils literal"><span class="pre">!=</span></code>, <code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code>, <code class="docutils literal"><span class="pre">&gt;=</span></code> により比較します。 さらに <code class="samp docutils literal"><em><span class="pre">string</span></em><span class="pre">.compare(</span><em><span class="pre">otherString</span></em><span class="pre">)</span></code> メソッでは -1, 0, 1 いずれかを返します。それぞれ <code class="samp docutils literal"><em><span class="pre">string</span></em></code> が <code class="samp docutils literal"><em><span class="pre">otherString</span></em></code> より 未満、等しい、超 に応じます。</p>
</li>
<li><p class="first"><code class="samp docutils literal"><em><span class="pre">string</span></em><span class="pre">[</span><em><span class="pre">index</span></em><span class="pre">]</span></code> を使用し、インデックスによるアクセスが可能です。与えられたインデックスに該当する1文字の文字列を結果として返します。 <code class="samp docutils literal"><em><span class="pre">index</span></em></code> は <span class="math">\([0...2^{31}-1]\)</span> の範囲である必要があります。</p>
</li>
<li><p class="first"><code class="samp docutils literal"><em><span class="pre">string</span></em><span class="pre">.hash()</span></code> メソッドにより、文字列の32-bit のハッシュ値を得ます。</p>
</li>
</ul>
</li>
<li><p class="first">C/C++言語と異なり、文字列にはヌル文字(ASCII 0)を許容します。</p>
</li>
<li><p class="first">文字列はそれ自体にエンコーディング（符号化）の概念を持ちません。つまりただの連続したバイトにすぎません。その文字列が使用されるアプリケーション空間において、文字列エンコーディングが決定されます。Fabric自体ではUTF-8エンコーディングを使用しますが、Fabricエクステンションでは、文字列をそれぞれ別のエンコーディングに変換する必要がある場合があります。</p>
</li>
<li><p class="first">KLの他の全ての型は、キャストし文字列へ変換することができます。この変換によりある値を人間可読な文字列とすることができます。カスタム型においてこの変換 ―  <code class="samp docutils literal"><span class="pre">function</span> <em><span class="pre">Type</span></em><span class="pre">.appendDesc(io</span> <span class="pre">String</span> <span class="pre">string)</span></code> メソッド ― はオーバーライド可能です。 see <a class="reference internal" href="globals.html#conversion-funcs"><span>Conversion Functions</span></a> を参照してください。</p>
</li>
</ul>
<p><code class="docutils literal"><span class="pre">String</span></code> 型の使用例:</p>
<div class="highlight-python"><div class="highlight"><pre>operator entry() {
  String a = &quot;A string&quot;;
  report(a);
  report(&quot;a has length &quot; + a.length);
  String b = &quot;Another string&quot;;
  report(b);
  String c = a + &quot; and &quot; + b;
  report(c);
  b += &quot; now includes &quot; + a;
  report(b);
}
</pre></div>
</div>
<p>出力:</p>
<div class="highlight-python"><div class="highlight"><pre>A string
a has length 8
Another string
A string and Another string
Another string now includes A string
</pre></div>
</div>
</div>
</div>
<div class="section" id="derived-types">
<span id="klpg-types-derived"></span><span id="index-8"></span><h2>派生型（Derived Types）<a class="headerlink" href="#derived-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>基本型に加え、KLは３つの派生型をサポートします。構造体（structures）配列（arrays）辞書（dictionaries）です。</p>
<div class="section" id="structures">
<span id="klpg-types-structures"></span><span id="index-9"></span><h3>構造体（Structures）<a class="headerlink" href="#structures" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>構造体（ <em class="dfn">structure</em> ）ではいくつかの型の値がメモリ上に一緒に配置されます。</p>
<p>構造体は通常、Fabric&#8217;s <span class="target" id="index-30"></span>registered type system を使いKL外に定義されますが、KLソースコード内に直接 <code class="docutils literal"><span class="pre">struct</span></code> キーワードを使い宣言することもできます。</p>
<div class="highlight-python"><div class="highlight"><pre>struct NewType {
  Float32 firstMember;
  String secondMember;
  Integer thirdMemberVarArray[], fourthMemberFixedArray[3];
};
</pre></div>
</div>
<p>注意：可変長配列は一番最後のメンバとして宣言します。派生型は任意にネストすることが可能です。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">全ての構造体の宣言は、グローバルスコープに置かれます。関数スコープ内での宣言は不可能です。</p>
</div>
<p>構造体に関する詳細：</p>
<ul class="simple">
<li><p class="first">構造体のメンバに対するアクセスには <code class="docutils literal"><span class="pre">.</span></code> (ドット) 演算子をJavaScript同様、使用します。</p>
</li>
<li><p class="first">現状、構造体メンバは C言語ライクなアライメントを使用します。 <a class="reference internal" href="#structure-alignment"><span>構造体メンバのアライメント</span></a> 参照).</p>
</li>
<li><p class="first">演算子オーバーロードが可能で、メソッド <em class="dfn">methods</em> を構造体に追加できます。 <a class="reference internal" href="globals.html#methods"><span>Methods</span></a> 参照</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">public</span></code>, <code class="docutils literal"><span class="pre">private</span></code>, <code class="docutils literal"><span class="pre">protected</span></code>, <code class="docutils literal"><span class="pre">permits</span></code> キーワードを使用し、構造体メンバ、メソッドに対するアクセス制御が可能です。 <a class="reference internal" href="#klpg-types-member-access"><span>構造体、オブジェクト、インタフェースでのアクセス制御</span></a> 参照</p>
</li>
</ul>
<p>構造体の使用例:</p>
<div class="highlight-python"><div class="highlight"><pre>struct MyNewType {
  Integer i;
  String s, t;
};

function entry() {
  MyNewType mnt;
  mnt.s = &quot;Hello!&quot;;
  mnt.i = 42;
  mnt.t = &quot;there!&quot;;
  report(mnt);
}
</pre></div>
</div>
<p>出力:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">{</span><span class="n">i</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="n">s</span><span class="p">:</span><span class="s">&quot;Hello!&quot;</span><span class="p">,</span><span class="n">t</span><span class="p">:</span><span class="s">&quot;there!&quot;</span><span class="p">}</span>
</pre></div>
</div>
<div class="section" id="structure-member-alignment">
<span id="structure-alignment"></span><span id="index-11"></span><h4>構造体メンバのアライメント<a class="headerlink" href="#structure-member-alignment" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>構造体メンバのアライメントは、C言語でのそれと同一です。従い、 Fabric Engine の EDK コードとのインタフェースでは、KLでの構造体に合わせた特別なアライメントの指定は必要ありません。</p>
<p>参考までに、KLの構造体のアライメントに関するルール（つまりC言語のディフォルトと一緒）は：</p>
<ul class="simple">
<li><p class="first">全ての型は、サイズとアライメントを持つ</p>
</li>
<li><p class="first">基本型のアライメントは、その型のサイズと同一</p>
</li>
<li><p class="first">構造体（全体）のアライメントはその構造体のメンバの型のうち一番大きい物</p>
</li>
<li><p class="first">メンバの構造体内でのバイト位置は、次に利用可能な構造体のオフセットからメンバの型のアライメントへ切り上げ選択されます。</p>
</li>
</ul>
</div>
<div class="section" id="structure-inheritance">
<span id="kplg-structure-inheritance"></span><span id="index-12"></span><h4>構造体の継承<a class="headerlink" href="#structure-inheritance" title="このヘッドラインへのパーマリンク">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.13.0 で追加.</span></p>
</div>
<p>ある構造体は基となる一つの構造体を継承（ <cite>inherit</cite> もしくは <cite>derive</cite> ）できます。特殊化した構造体は、基底構造体より全てのメンバとメソッドを継承します。</p>
<p><code class="samp docutils literal"><span class="pre">struct</span> <em><span class="pre">SpecializedType</span></em> <span class="pre">:</span> <em><span class="pre">BaseType</span></em></code> 構文を使用し継承関係の宣言をします。特殊化した構造体は基底構造体へとノーコストで <cite>cast</cite> が可能です。 <code class="samp docutils literal"><span class="pre">.parent</span></code> アクセッサにより、明示的にキャストします。</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="kr">struct</span> <span class="nx">Shape</span> <span class="p">{</span>
  <span class="kr">Float32</span> <span class="nx">centerX</span><span class="p">,</span> <span class="nx">centerY</span><span class="p">;</span>
<span class="p">};</span>

<span class="kr">struct</span> <span class="nx">Circle</span> <span class="o">:</span> <span class="nx">Shape</span> <span class="p">{</span>
  <span class="kr">Float32</span> <span class="nx">radius</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Circle</span> <span class="nx">c</span><span class="p">;</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">centerX</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">centerY</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">radius</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

  <span class="nb">report</span><span class="p">(</span> <span class="nx">c</span> <span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span> <span class="nx">c</span><span class="p">.</span><span class="nx">parent</span> <span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">{centerX:+1.0,centerY:+2.0,radius:+3.0}</span>
<span class="cm">{centerX:+1.0,centerY:+2.0}</span>

<span class="cm">*/</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>基底型へとキャストすると、その構造体は特殊化した振舞を全て失います。オブジェクト（ <a class="reference internal" href="#kplg-object-inheritance"><span>objects</span></a> ）との違いです。</p>
<div class="last highlight-kl"><div class="highlight"><pre><span class="kr">struct</span> <span class="nx">Shape</span> <span class="p">{</span>
  <span class="kr">Float32</span> <span class="nx">centerX</span><span class="p">,</span> <span class="nx">centerY</span><span class="p">;</span>
<span class="p">};</span>

<span class="kr">struct</span> <span class="nx">Circle</span> <span class="o">:</span> <span class="nx">Shape</span> <span class="p">{</span>
  <span class="kr">Float32</span> <span class="nx">radius</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">printShape</span><span class="p">(</span> <span class="nx">Shape</span> <span class="nx">s</span> <span class="p">)</span> <span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span> <span class="nx">s</span><span class="p">.</span><span class="nx">type</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="nx">s</span> <span class="p">);</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Circle</span> <span class="nx">c</span><span class="p">;</span>
  <span class="nx">printShape</span><span class="p">(</span> <span class="nx">c</span> <span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">Shape: {centerX:+0.0,centerY:+0.0}</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="objects">
<span id="klpg-types-objects"></span><span id="index-13"></span><h3>オブジェクト（Objects）<a class="headerlink" href="#objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.12.0 で変更: </span>オブジェクト型変数の &#8220;empty construction&#8221; は不可能になりました</p>
</div>
<p>オブジェクト（ <em class="dfn">object</em> ）は、メモリ内に幾つかの型の値を一緒に保持するという点において構造体（ <a class="reference internal" href="#klpg-types-structures"><span>structure</span></a> ）に似ています。違いは、オブジェクトが「参照によるコピー（copy-by-reference）」であるのに対し、構造体では「値によるコピー（copy-by-value）」な点です。オブジェクトは <em class="dfn">constructed</em> され内部において参照カウントされます。さらにオブジェクトでは、そのオブジェクトでのサポートが保証されるメソッドの集合の <a class="reference internal" href="#klpg-types-interfaces"><span>interfaces</span></a> をサポートします。</p>
<p>オブジェクトは構造体とほぼ同じように使用できます。おおきな違いは、copy-by-referenceな点、コンストラクトされなくてはいけない点です。KLは内部に各オブジェクトの参照番号のトラックを保持し、そのオブジェクトの最後の参照が破棄された際、オブジェクトは開放されます。スコープから外れるか、オブジェクトに  <code class="code docutils literal"><span class="pre">null</span></code>  が割り当てられると、オブジェクトは参照を落とします。</p>
<p>KLコード中、 <code class="code docutils literal"><span class="pre">object</span></code> キーワードを使用しオブジェクトを定義します。このシンタックスは構造体とほぼ一緒です。 <a class="reference internal" href="#klpg-types-structures"><span>structures</span></a> 参照</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="c1">// An object with two members</span>
<span class="kr">object</span> <span class="nx">Obj</span> <span class="p">{</span>
  <span class="kr">String</span> <span class="nx">s</span><span class="p">;</span>
  <span class="kr">UInt32</span> <span class="nx">n</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>必要に応じ、オブジェクトはある1つの基底オブジェクトを継承し、さらに1つ以上の <a class="reference internal" href="#klpg-types-interfaces"><span>interfaces</span></a> を実装することができます。オブジェクトの名前の後に、継承するオブジェクト、実装するインターフェースを示します。</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="c1">// An object with two members that implements two interfaces</span>
<span class="kr">object</span> <span class="nx">MyObjType</span> <span class="o">:</span> <span class="nx">BaseObjType</span><span class="p">,</span> <span class="nx">IntOne</span><span class="p">,</span> <span class="nx">IntTwo</span> <span class="p">{</span>
  <span class="kr">String</span> <span class="nx">s</span><span class="p">;</span>
  <span class="kr">UInt32</span> <span class="nx">n</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>型にオブジェクトを与えた変数は、そのオブジェクトの名とともに宣言します。</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="c1">// A variable of type MyObjType</span>
<span class="nx">MyObjType</span> <span class="nx">obj</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span> <span class="c1">// reports: null</span>
</pre></div>
</div>
<p>値 <code class="code docutils literal"><span class="pre">null</span></code> は存在しないオブジェクトを参照します。オブジェクトが <code class="code docutils literal"><span class="pre">null</span></code> であると、report可能ですが、実行時にそのオブジェクトのメンバを参照したり、メソッドを呼び出すと、ランタイムエラーとなります。</p>
<p>どのオブジェクト型の変数も <code class="code docutils literal"><span class="pre">null</span></code> に設定可能です。 <code class="code docutils literal"><span class="pre">null</span></code> オブジェクトに対するほとんど操作は、実行時エラーとなります。正常なオブジェクトの作成には、コンストラクトします。コンストラクトする2種類の文法：</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="nx">MyObjType</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">MyObjType</span><span class="p">();</span> <span class="c1">// calls the default constructor</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span> <span class="c1">// reports: {s:&quot;&quot;,n:0}</span>
<span class="nx">MyObjType</span> <span class="nx">obj2</span><span class="p">();</span> <span class="c1">// also calls the default constructor</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">obj2</span><span class="p">);</span> <span class="c1">// reports: {s:&quot;&quot;,n:0}</span>
<span class="nx">obj2</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// releases the object referenced by obj2</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">obj2</span><span class="p">);</span> <span class="c1">// throws an error</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">オブジェクトは&#8221;empty constructed&#8221;不可能です。明示的にコンストラクトするか、明示的に <code class="code docutils literal"><span class="pre">null</span></code> に設定します。</p>
</div>
<p><a class="reference internal" href="globals.html#klpg-constructor"><span>Constructors</span></a> と <a class="reference internal" href="globals.html#klpg-destructor"><span>destructors</span></a> を構造体同様、オブジェクトでも指定することができます</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="c1">// Provide a default constructor</span>
<span class="kd">function</span> <span class="nx">MyObjType</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">n</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Provide a constructor that takes parameters</span>
<span class="kd">function</span> <span class="nx">MyObjType</span><span class="p">(</span><span class="kr">String</span> <span class="nx">s</span><span class="p">,</span> <span class="kr">UInt32</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="nx">s</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">n</span> <span class="o">=</span> <span class="nx">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// later..</span>
<span class="nx">MyObjType</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">MyObjType</span><span class="p">();</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span> <span class="c1">// reports: {s:&quot;hello&quot;,n:42}</span>
<span class="nx">obj</span> <span class="o">=</span> <span class="nx">MyObjType</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span> <span class="c1">// reports: {s:&quot;foo&quot;,n:7}</span>
</pre></div>
</div>
<p>他の同型オブジェクトから特定のオブジェクトをコンストラクトすると、新しいオブジェクトは古いオブジェクトを参照します。この場合、新しいオブジェクトは実際には作られていません。つまり参照を通し、そのうちの1つのオブジェクトに変更が加わると、もう片方のオブジェクトも同様、変更されます。</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="nx">MyObjType</span> <span class="nx">o1</span><span class="p">(</span><span class="s2">&quot;bar&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="nx">MyObjType</span> <span class="nx">o2</span> <span class="o">=</span> <span class="nx">o1</span><span class="p">;</span>
<span class="nx">o2</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="s2">&quot;baz&quot;</span><span class="p">;</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">o1</span><span class="p">);</span> <span class="c1">// reports: {s:&quot;baz&quot;,n:3}</span>
</pre></div>
</div>
<p>ユーザ独自のコピーコンストラクタを定義することはできません。以下の理由のためです。コピーコンストラクタは既存のオブジェクトに対し、参照を常に１つ加算します。かりに新規オブジェクトをインスタンス化したいのであれば、 <code class="docutils literal"><span class="pre">clone()</span></code> メソッド（ <a class="reference internal" href="#klpg-types-objects-clone"><span>Object clone() メソッド</span></a> 参照）か、カスタムメソッドを使用します。</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** Example: Duplicating an object using a custom method</span>
<span class="cm">*/</span>

<span class="c1">// not permitted, custom copy constructor invalid for objects</span>
<span class="c1">// function MyObjType(MyObjType o)</span>
<span class="c1">// {</span>
<span class="c1">//   // ...</span>
<span class="c1">// }</span>

<span class="kr">object</span> <span class="nx">MyObjType</span>
<span class="p">{</span>
  <span class="kr">String</span> <span class="nx">s</span><span class="p">;</span>
  <span class="kr">Integer</span> <span class="nx">n</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// return a new object using a custom method</span>
<span class="kd">function</span> <span class="nx">MyObjType</span> <span class="nx">MyObjType</span><span class="p">.</span><span class="nx">copy</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nx">MyObjType</span> <span class="nx">o</span> <span class="o">=</span> <span class="nx">MyObjType</span><span class="p">();</span>
  <span class="nx">o</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">s</span><span class="p">;</span>
  <span class="nx">o</span><span class="p">.</span><span class="nx">n</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">n</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">o</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nx">MyObjType</span> <span class="nx">o1</span><span class="p">();</span>
  <span class="nx">o1</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span><span class="p">;</span>
  <span class="nx">o1</span><span class="p">.</span><span class="nx">n</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>

  <span class="nx">MyObjType</span> <span class="nx">o2</span> <span class="o">=</span> <span class="nx">o1</span><span class="p">.</span><span class="nx">copy</span><span class="p">();</span>

  <span class="nx">o2</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="s2">&quot;bar&quot;</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;o1 = &quot;</span> <span class="o">+</span> <span class="nx">o1</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;o2 = &quot;</span> <span class="o">+</span> <span class="nx">o2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">o1 = {s:&quot;foo&quot;,n:42}</span>
<span class="cm">o2 = {s:&quot;bar&quot;,n:42}</span>

<span class="cm">*/</span>
</pre></div>
</div>
<p>構造体同様、オブジェクトには任意のメソッドを定義できます。これらのメソッドは <code class="samp docutils literal"><em><span class="pre">object</span></em><span class="pre">.</span><em><span class="pre">methodName</span></em><span class="pre">(</span><em><span class="pre">arg</span></em><span class="pre">,</span><em><span class="pre">arg</span></em><span class="pre">,...)</span></code> 構文を使用し呼び出します。 <code class="code docutils literal"><span class="pre">null</span></code> に対するメソッドの呼び出しは実行時例外を引き起こします。</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="kd">function</span> <span class="nx">MyObjType</span><span class="p">.</span><span class="nx">reportMe</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;reportMe: s=&quot;</span><span class="o">+</span><span class="k">this</span><span class="p">.</span><span class="nx">s</span><span class="o">+</span><span class="s2">&quot; n=&quot;</span><span class="o">+</span><span class="nx">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">MyObjType</span> <span class="nx">obj</span><span class="p">(</span><span class="s2">&quot;Fred&quot;</span><span class="p">,</span> <span class="mi">49</span><span class="p">);</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">reportMe</span><span class="p">();</span> <span class="c1">// reports: reportMe: s=Fred n=49</span>
</pre></div>
</div>
<p>構造体同様、オブジェクトのメンバへのアクセスには <code class="samp docutils literal"><em><span class="pre">object</span></em><span class="pre">.</span><em><span class="pre">memberName</span></em></code> 構文を使用します。<code class="code docutils literal"><span class="pre">null</span></code> オブジェクトに対する <code class="code docutils literal"><span class="pre">.</span></code> （ドット）の使用も実行時例外となります。</p>
<p>オブジェクトのさらなる特徴:</p>
<ul class="simple">
<li><p class="first">オブジェクト型の値が <code class="code docutils literal"><span class="pre">Boolean</span></code> に変換されると、そのオブジェクトが <code class="code docutils literal"><span class="pre">null</span></code> ではない場合 <code class="code docutils literal"><span class="pre">true</span></code> となる</p>
</li>
<li><p class="first"><a class="reference internal" href="ops-exprs.html#equality-ops"><span>equality operators</span></a> <code class="samp docutils literal"><em><span class="pre">obj1</span></em> <span class="pre">==</span> <em><span class="pre">obj2</span></em></code> and <code class="samp docutils literal"><em><span class="pre">obj1</span></em> <span class="pre">!=</span> <em><span class="pre">obj2</span></em></code> はオブジェクトがオーバーロドされているか、 <code class="code docutils literal"><span class="pre">null</span></code> と比較されている場合のみ、有効です。 <a class="reference internal" href="ops-exprs.html#identity-ops"><span>identity operators</span></a> <code class="samp docutils literal"><em><span class="pre">obj1</span></em> <span class="pre">===</span> <em><span class="pre">obj2</span></em></code> and <code class="samp docutils literal"><em><span class="pre">obj1</span></em> <span class="pre">!==</span> <em><span class="pre">obj2</span></em></code> は常に有効で、同一のオブジェクトを参照してりうかどうかに依って比較されます。 (すなわち変更が双方に影響します)</p>
</li>
<li><p class="first">オブジェクト型の値は、 <code class="samp docutils literal"><span class="pre">&lt;objectValue&gt;.uid()</span></code> をサポートしユニークな UInt64 を返します。オブジェクトの同定に使用できます。この値は、そのオブジェクトをそれがサポートするどのようなインターフェースにキャストしたものに対し <cite>.uid()</cite> を呼び出した結果と同一です。</p>
</li>
<li><p class="first">オブジェクトに <code class="code docutils literal"><span class="pre">null</span></code> を代入するとそのオブジェクトが過去に示した参照全てをドロップします。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">public</span></code>, <code class="docutils literal"><span class="pre">private</span></code>, <code class="docutils literal"><span class="pre">protected</span></code>, <code class="docutils literal"><span class="pre">permits</span></code> キーワードにより、オブジェクトのメンバ、メソッドに対するアクセス制御が可能です。 <a class="reference internal" href="#klpg-types-member-access"><span>構造体、オブジェクト、インタフェースでのアクセス制御</span></a> 参照</p>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">オブジェクト型の変数は、構造体を示す事はできません。オブジェクト、またインターフェイスは根本的に構造体とは異なります。 <a class="reference internal" href="#klpg-objects-versus-structures"><span>オブジェクト vs 構造体</span></a> 節参照</p>
</div>
<p>オブジェクトの別な使用例：</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** Example: Objects</span>
<span class="cm">*/</span>

<span class="kr">object</span> <span class="nx">Foo</span> <span class="p">{</span>
  <span class="kr">SInt32</span> <span class="nx">intMember</span><span class="p">;</span>
  <span class="kr">String</span> <span class="nx">stringMember</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// A non-default constructor for Foo</span>
<span class="kd">function</span> <span class="nx">Foo</span><span class="p">(</span><span class="kr">SInt32</span> <span class="nx">i</span><span class="p">,</span> <span class="kr">String</span> <span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">intMember</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">stringMember</span> <span class="o">=</span> <span class="nx">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Foo</span> <span class="nx">foo1</span> <span class="o">=</span> <span class="nx">Foo</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="s2">&quot;foo&quot;</span><span class="p">);</span> <span class="c1">// call the non-default constructor</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">foo1</span><span class="p">);</span>
  <span class="nx">Foo</span> <span class="nx">foo2</span><span class="p">();</span> <span class="c1">// call the default constructor</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">foo2</span><span class="p">);</span>
  <span class="nx">Foo</span> <span class="nx">foo3</span><span class="p">(</span><span class="nx">foo1</span><span class="p">);</span> <span class="c1">// make foo3 a reference to foo1</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">foo3</span><span class="p">);</span>
  <span class="nx">foo3</span><span class="p">.</span><span class="nx">intMember</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="c1">// since foo1 and foo3 refer to the same object, both change!</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">foo1</span><span class="p">);</span>
  <span class="nx">Foo</span> <span class="nx">foo4</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// a null object</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">foo4</span><span class="p">);</span>
  <span class="nx">foo4</span><span class="p">.</span><span class="nx">intMember</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">// throws an exception</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">{intMember:32,stringMember:&quot;foo&quot;}</span>
<span class="cm">{intMember:0,stringMember:&quot;&quot;}</span>
<span class="cm">{intMember:32,stringMember:&quot;foo&quot;}</span>
<span class="cm">{intMember:20,stringMember:&quot;foo&quot;}</span>
<span class="cm">null</span>
<span class="cm">Error: (stdin):29:3: dereferenced null object</span>
<span class="cm">KL stack trace:</span>
<span class="cm">[ST] 1 kl.internal.String.SetErrorDataPtrAndLength.AS0()</span>
<span class="cm">[ST] 2 function.setError.R.ST()</span>
<span class="cm">[ST] 3 operator.entry() (stdin):29</span>
<span class="cm">[ST] 4 kl.internal.entry.stub.cpu()</span>

<span class="cm">*/</span>
</pre></div>
</div>
<div class="section" id="the-object-clone-method">
<span id="klpg-types-objects-clone"></span><h4>Object <code class="docutils literal"><span class="pre">clone()</span></code> メソッド<a class="headerlink" href="#the-object-clone-method" title="このヘッドラインへのパーマリンク">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.15.0 で追加.</span></p>
</div>
<p>KLでの他の多くの型同様オブジェクトは、オブジェクトのディープコピーを行う <code class="docutils literal"><span class="pre">clone()</span></code> メソッドをサポートします。全てのオブジェクトはディフォルトで <code class="docutils literal"><span class="pre">clone()</span></code> を実装しています。独自定義したメソッド <code class="docutils literal"><span class="pre">&lt;ObjectType&gt;.cloneMembersTo(io</span> <span class="pre">&lt;ObjectType&gt;</span> <span class="pre">that)</span></code> を記述し <code class="docutils literal"><span class="pre">clone()</span></code> の振舞を、変更できます。このメソッドはオブジェクトの複製処理を行う際、自動的に呼びだされます。以下に示す：</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** Example: Object Custom Clone</span>
<span class="cm">*/</span>

<span class="kr">object</span> <span class="nx">Obj</span>
<span class="p">{</span>
  <span class="kr">String</span> <span class="nx">s</span><span class="p">;</span>
  <span class="kr">Integer</span> <span class="nx">n</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">Obj</span><span class="p">.</span><span class="nx">cloneMembersTo</span><span class="p">(</span><span class="k">io</span> <span class="nx">Obj</span> <span class="nx">that</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nx">that</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">s</span> <span class="o">+</span> <span class="s2">&quot; cloned&quot;</span><span class="p">;</span>
  <span class="nx">that</span><span class="p">.</span><span class="nx">n</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nx">Obj</span> <span class="nx">obj1</span><span class="p">();</span>
  <span class="nx">obj1</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="s2">&quot;string&quot;</span><span class="p">;</span>
  <span class="nx">obj1</span><span class="p">.</span><span class="nx">n</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;obj1 = &quot;</span> <span class="o">+</span> <span class="nx">obj1</span><span class="p">);</span>

  <span class="nx">Obj</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="nx">obj1</span><span class="p">.</span><span class="nx">clone</span><span class="p">();</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;obj2 = &quot;</span> <span class="o">+</span> <span class="nx">obj2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">obj1 = {s:&quot;string&quot;,n:42}</span>
<span class="cm">obj2 = {s:&quot;string cloned&quot;,n:84}</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="object-inheritance">
<span id="kplg-object-inheritance"></span><h4>オブジェクトの継承<a class="headerlink" href="#object-inheritance" title="このヘッドラインへのパーマリンク">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.13.0 で追加.</span></p>
</div>
<p>構造体と同じように、オブジェクトは他のベースオブジェクトを1つ継承できます。特殊化したオブジェクトは、基底オブジェクトのすべてのメンバとメソッドを引き継ぎます。 <code class="samp docutils literal"><span class="pre">struct</span> <em><span class="pre">SpecializedType</span></em> <span class="pre">:</span> <em><span class="pre">BaseType</span></em></code> 構文を使用し継承関係を宣言します。</p>
<p><code class="samp docutils literal"><em><span class="pre">object</span></em><span class="pre">.</span><em><span class="pre">parent</span></em></code> 構文により、基底オブジェクトから継承している場合、明示的に基底型へとキャストを行います。特殊化したメンバやメソッドが基底オブジェクトと異なる定義を持つ場合、便利です。</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="kr">object</span> <span class="nx">MyBaseObject</span> <span class="p">{</span>
  <span class="kr">Float32</span> <span class="nx">f</span><span class="p">;</span>
  <span class="nx">Size</span> <span class="nx">s</span><span class="p">;</span>
<span class="p">};</span>

<span class="kr">object</span> <span class="nx">MyObject</span> <span class="o">:</span> <span class="nx">MyBaseObject</span> <span class="p">{</span>
  <span class="nx">Size</span> <span class="nx">s</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">MyObject</span> <span class="nx">o</span><span class="p">();</span>
  <span class="nx">o</span><span class="p">.</span><span class="nx">f</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
  <span class="nx">o</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="nx">o</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">o</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">{f:+0.5,s:1,s:2}</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="interfaces">
<span id="klpg-types-interfaces"></span><span id="index-14"></span><h3>インタフェース（Interfaces）<a class="headerlink" href="#interfaces" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.12.0 で変更: </span>インタフェース型の変数の &#8220;empty construction&#8221; の使用が不可能になりました</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.15.0 で変更: </span><code class="docutils literal"><span class="pre">&lt;typeExpr&gt;.createNew()</span></code> メソッドが追加されました</p>
</div>
<p><em class="dfn">interface</em> とは、あるオブジェクトが実装することに同意するメソッドを集めた一連のセットです。オブジェクトは、オブジェクトの宣言にインタフェースの名前を入れるだけでなくインタフェースの各メソッドを実装することで、インタフェースを実装します。プログラマはどのようなオブジェクトの型であっても、インタフェースを実装するオブジェクトであれば、ファーストクラス型としてインタフェースを使用し参照することができます。</p>
<p><code class="code docutils literal"><span class="pre">interface</span></code> キーワードによりインタフェースを定義します。インタフェース定義は構造体や、オブジェクト定義に似ています。メンバやメソッドは指定することを除きます。例えば：</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="kr">interface</span> <span class="nx">MyInt</span> <span class="p">{</span>
  <span class="kr">UInt32</span> <span class="nx">foo</span><span class="p">();</span>
  <span class="nx">bar</span><span class="o">?</span><span class="p">(</span><span class="k">io</span> <span class="kr">String</span> <span class="nx">s</span><span class="p">);</span>
  <span class="kr">Float32</span> <span class="nx">baz</span><span class="o">!</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p>このサンプルでは、インタフェース <code class="code docutils literal"><span class="pre">MyInt</span></code> に３つのメソッドを与え、定義します。引数パラメータと、返り値の型は、構造体やオブジェクト同様におきます（ <a class="reference internal" href="globals.html#methods"><span>methods</span></a> ）。ただし、 <code class="code docutils literal"><span class="pre">function</span></code> キーワードと、型名は省きます。メソッド呼び出しによりそのオブジェクトが変更されるかどうか明示的に示す <code class="code docutils literal"><span class="pre">!</span></code> and <code class="code docutils literal"><span class="pre">?</span></code> は機能します。</p>
<p>インタフェースには、それを実装するオブジェクトがサポートしなければならない一連のメソッド「のみ」を指定します。インタフェースを使用するには、そのインタフェースをサポートしたオブジェクトを定義する必要があります。</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="c1">// An object type that implements MyInt</span>
<span class="kr">object</span> <span class="nx">MyObj</span> <span class="o">:</span> <span class="nx">MyInt</span> <span class="p">{</span>
  <span class="kr">UInt32</span> <span class="nx">n</span><span class="p">;</span>
  <span class="kr">String</span> <span class="nx">s</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="kr">UInt32</span> <span class="nx">MyObj</span><span class="p">.</span><span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">MyObj</span><span class="p">.</span><span class="nx">bar</span><span class="o">?</span><span class="p">(</span><span class="k">io</span> <span class="kr">String</span> <span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">s</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="kr">Float32</span> <span class="nx">MyObj</span><span class="p">.</span><span class="nx">baz</span><span class="o">!</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mf">3.14</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">n</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>インタフェースの実装には、オブジェクト型名直後にインタフェースを、そして各メソッドの実装の一覧を列記します。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">オブジェクトの実装に、インタフェースに必要なメソッド定義が一つでも欠けていると、コンパイル時エラーとなります。</p>
</div>
<p>オブジェクトには複数のインタフェースを実装できます。</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="kr">interface</span> <span class="nx">MyOtherInt</span> <span class="p">{</span>
  <span class="nx">fred</span><span class="p">();</span>
  <span class="kr">Float32</span> <span class="nx">baz</span><span class="o">!</span><span class="p">();</span>
<span class="p">};</span>

<span class="kr">object</span> <span class="nx">MyDoubleObj</span> <span class="o">:</span> <span class="nx">MyInt</span><span class="p">,</span> <span class="nx">MyOtherInt</span> <span class="p">{</span>
  <span class="kr">Boolean</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="kr">UInt32</span> <span class="nx">MyDoubleObj</span><span class="p">.</span><span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ....</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">MyDoubleObj</span><span class="p">.</span><span class="nx">bar</span><span class="o">?</span><span class="p">(</span><span class="k">io</span> <span class="kr">String</span> <span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ....</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="kr">Float32</span> <span class="nx">MyDoubleObj</span><span class="p">.</span><span class="nx">baz</span><span class="o">!</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">b</span><span class="p">;</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">b</span><span class="o">?</span> <span class="o">-</span><span class="mf">7.5</span><span class="o">:</span> <span class="mf">14.5</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">MyDoubleObj</span><span class="p">.</span><span class="nx">fred</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>メソッドを共有するような複数のインタフェースを、オブジェクトがサポートすることは可能です。それにはメソッドを1度だけ実装します。実装したメソッドは全てのインタフェースから共有されます。</p>
<p>インタフェースを定義すると、あるインタフェースを実装したオブジェクトを参照する変数を宣言できます。 <code class="samp docutils literal"><em><span class="pre">int</span></em><span class="pre">.</span><em><span class="pre">methodName</span></em><span class="pre">(</span><em><span class="pre">arg</span></em><span class="pre">,</span> <em><span class="pre">arg</span></em><span class="pre">,</span> <span class="pre">...)</span></code> 構文により、そのオブジェクトのメソッドを呼び出します。</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="nx">MyInt</span> <span class="nx">myInt</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// does not refer to an object</span>
<span class="nx">myInt</span> <span class="o">=</span> <span class="nx">MyObj</span><span class="p">();</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">myInt</span><span class="p">);</span> <span class="c1">// reports: {n:0, s:&quot;&quot;} since it is a MyObj</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">myInt</span><span class="p">.</span><span class="nx">baz</span><span class="p">());</span> <span class="nx">reports</span><span class="o">:</span> <span class="mf">0.0</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">myInt</span><span class="p">.</span><span class="nx">baz</span><span class="p">());</span> <span class="nx">reports</span><span class="o">:</span> <span class="mf">3.14</span>
<span class="nx">myInt</span> <span class="o">=</span> <span class="nx">MyDoubleObj</span><span class="p">();</span> <span class="c1">// releases old object</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">myInt</span><span class="p">);</span> <span class="c1">// reports: {b:false}</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">myInt</span><span class="p">.</span><span class="nx">baz</span><span class="p">());</span> <span class="nx">reports</span><span class="o">:</span> <span class="o">-</span><span class="mf">7.5</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">myInt</span><span class="p">.</span><span class="nx">baz</span><span class="p">());</span> <span class="nx">reports</span><span class="o">:</span> <span class="mf">14.5</span>
</pre></div>
</div>
<p><code class="samp docutils literal"><em><span class="pre">interface</span></em><span class="pre">.type()</span></code> メソッドのより、インタフェースから参照しているオブジェクトの型を確認します。割当もしくはキャストにより、特定のオブジェクトを得ます。これにより、KLでの単純な「弱い（もしくは実行時）型付け」の形式（simple form of weak(or runtime) typing）を可能にします。</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="nx">myInt</span><span class="p">.</span><span class="nx">type</span><span class="p">()</span> <span class="o">==</span> <span class="nx">MyObj</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">MyObj</span> <span class="nx">myObj</span> <span class="o">=</span> <span class="nx">myInt</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">myInt</span><span class="p">.</span><span class="nx">type</span><span class="p">()</span> <span class="o">==</span> <span class="nx">MyDoubleObj</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">MyDoubleObj</span> <span class="nx">myDoubleObj</span> <span class="o">=</span> <span class="nx">myInt</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このケースでは、この式の型は <code class="code docutils literal"><span class="pre">Type</span></code> 型です。したがって、 <code class="docutils literal"><span class="pre">&lt;typeExpr&gt;.createNew()</span></code> メソッドを呼ぶと、新しいオブジェクトインスタンスを作成します。インタフェースは空コンストラクタを使用しインスタンスになります。結果として、  <a class="reference internal" href="#klpg-interfaces-object"><span>Object interface</span></a>  型になります。</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** Example: &lt;typeExpr&gt;.createNew()</span>
<span class="cm">*/</span>

<span class="kr">object</span> <span class="nx">Obj</span>
<span class="p">{</span>
  <span class="kr">String</span> <span class="nx">s</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nx">Obj</span> <span class="nx">obj1</span><span class="p">();</span>
  <span class="nx">obj1</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;obj1 = &quot;</span> <span class="o">+</span> <span class="nx">obj1</span><span class="p">);</span>

  <span class="nx">Object</span> <span class="nx">abstractObject</span> <span class="o">=</span> <span class="nx">obj1</span><span class="p">;</span>

  <span class="nx">Obj</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="nx">abstractObject</span><span class="p">.</span><span class="nx">type</span><span class="p">.</span><span class="nx">createNew</span><span class="p">();</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;obj2 = &quot;</span> <span class="o">+</span> <span class="nx">obj2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>
<span class="cm">(stdin):19:7: warning: must use parentheses to call methods (deprecation; will become an error in next version)</span>

<span class="cm">obj1 = {s:&quot;hello&quot;}</span>
<span class="cm">obj2 = {s:&quot;&quot;}</span>

<span class="cm">*/</span>
</pre></div>
</div>
<p>インタフェースを間違ったオブジェクトへ、割当もしくはキャストすると、実行時例外となります。型がインタフェースである値を、型が他のインタフェースである変数へと割り当てる事もできます。つまり、基礎となるオブジェクトが、第2のインタフェースをサポートする場合、そのオブジェクトの第2のインタフェースへの <code class="code docutils literal"><span class="pre">null</span></code> ではない参照を得ることができます。第2のインタフェースをサポートしていなければ、実行時例外が発生します。</p>
<p>インタフェースのさらなる特徴</p>
<ul class="simple">
<li><p class="first"><code class="code docutils literal"><span class="pre">Boolean</span></code> へのキャストがオブジェクト同様正常に可能です。 <code class="code docutils literal"><span class="pre">null</span></code> を参照しているかどうかをチェックします</p>
</li>
<li><p class="first">比較演算子 <code class="samp docutils literal"><em><span class="pre">int1</span></em> <span class="pre">==</span> <em><span class="pre">int2</span></em></code>, <code class="samp docutils literal"><em><span class="pre">int1</span></em> <span class="pre">!=</span> <em><span class="pre">int2</span></em></code>,そして同一比較演算子 <code class="samp docutils literal"><em><span class="pre">int1</span></em> <span class="pre">===</span> <em><span class="pre">int2</span></em></code>, <code class="samp docutils literal"><em><span class="pre">int1</span></em> <span class="pre">!==</span> <em><span class="pre">int2</span></em></code>, では2つのインタフェース同士が、同一（あるは別）のオブジェクトを参照するかどうかを判断します。（以前に参照されていたオブジェクトならなんでも）</p>
</li>
<li><p class="first">インタフェース型の値は <code class="samp docutils literal"><span class="pre">&lt;interfaceValue&gt;.uid()</span></code> メソッドをサポートし、インタフェースの参照するオブジェクトの同一性に依存した、ユニークな UInt64 を返します。この値はそのインタフェースの参照するオブジェクトで  <cite>.uid()</cite> を呼んだ時の値と同じになります。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">public</span></code>, <code class="docutils literal"><span class="pre">private</span></code>, <code class="docutils literal"><span class="pre">protected</span></code>, <code class="docutils literal"><span class="pre">permits</span></code> キーワードによりインタフェースのメソッドに対するアクセス制御が可能です。 <a class="reference internal" href="#klpg-types-member-access"><span>構造体、オブジェクト、インタフェースでのアクセス制御</span></a> 参照</p>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">インタフェース型の変数では構造体を示すことはできません。オブジェクトとインタフェースは根本的に構造体とは異なります。  <a class="reference internal" href="#klpg-objects-versus-structures"><span>オブジェクト vs 構造体</span></a> 節参照</p>
</div>
<div class="section" id="the-object-interface">
<span id="klpg-interfaces-object"></span><h4><code class="code docutils literal"><span class="pre">Object</span></code> インタフェース<a class="headerlink" href="#the-object-interface" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>事前に定義された <code class="code docutils literal"><span class="pre">Object</span></code> と呼ばれる特別なインタフェースが存在します。全てのKLでのオブジェクトで常にサポートします。このインタフェースにより、KL言語の過去のバージョンとの後方互換性と、さらに任意のオブジェクトへの参照を渡すシンプルな方法（C言語での &#8220;void pointer&#8221;のようなもの）を提供します。この <code class="code docutils literal"><span class="pre">Object</span></code> インタフェースではメソッドを提供しません。</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="kr">object</span> <span class="nx">MyObj</span> <span class="p">{</span> <span class="c1">// implicitly implements Object</span>
  <span class="kr">String</span> <span class="nx">s</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Object</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">MyObj</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="structure-object-and-interface-access-contols">
<span id="klpg-types-member-access"></span><h4>構造体、オブジェクト、インタフェースでのアクセス制御<a class="headerlink" href="#structure-object-and-interface-access-contols" title="このヘッドラインへのパーマリンク">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.15.0 で追加.</span></p>
</div>
<p>構造体、オブジェクト、インタフェースのメンバやメソッドへのアクセスは、 <code class="docutils literal"><span class="pre">public</span></code>, <code class="docutils literal"><span class="pre">private</span></code> and <code class="docutils literal"><span class="pre">protected</span></code> キーワードにより制御されます。これらのキーワードは C++と同じように動作します。</p>
<ul class="simple">
<li><p class="first"><code class="docutils literal"><span class="pre">public</span></code> が付けられたメンバやメソッドは、ソースコードどこからでもアクセス可能です。アクセス修飾子がつけられない場合のディフォルトの動作でもあります。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">private</span></code> と付けられたメンバやメソッドは、構造体もしくはオブジェクトないのメソッドからのみアクセス可能です。他の場からのアクセスは、コンパイル時エラーとなります。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">protected</span></code> と付けられたメンバやメソッドは、その構造体もしくはオブジェクトおよび、それらを継承した構造体もしくはオブジェクトからのみアクセス可能です。それ以外の場からのアクセスはコンパイル時エラーとなります。</p>
</li>
</ul>
<div class="highlight-kl"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** Example: Member and Method Access Controls</span>
<span class="cm">*/</span>

<span class="kr">struct</span> <span class="nx">A</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="kr">UInt32</span> <span class="nx">n</span><span class="p">;</span> <span class="c1">// can only be access by methods of A</span>
  <span class="k">protected</span> <span class="kr">String</span> <span class="nx">s</span><span class="p">;</span> <span class="c1">// can only be accessed by methods of A and structures that inherit from A</span>
<span class="p">};</span>

<span class="k">protected</span> <span class="nx">A</span><span class="p">.</span><span class="nx">bar</span><span class="p">()</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kr">struct</span> <span class="nx">B</span> <span class="o">:</span> <span class="nx">A</span>
<span class="p">{</span>
<span class="p">};</span>

<span class="k">public</span> <span class="nx">B</span><span class="p">.</span><span class="nx">foo</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">n</span><span class="p">);</span> <span class="c1">// error since n is private</span>
  <span class="nb">report</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">s</span><span class="p">);</span> <span class="c1">// ok since n is protected</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">bar</span><span class="p">();</span> <span class="c1">// ok since A.bar() is procted</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nx">B</span> <span class="nx">b</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">n</span><span class="p">);</span> <span class="c1">// error since n is private</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">s</span><span class="p">);</span> <span class="c1">// error since n is protected</span>
  <span class="nx">b</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span> <span class="c1">// ok since B.foo() is public</span>
  <span class="nx">b</span><span class="p">.</span><span class="nx">bar</span><span class="p">();</span> <span class="c1">// error since A.bar() is protected</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>
<span class="cm">(stdin):30:3: Calling function &#39;report&#39;:</span>
<span class="cm">(stdin):30:10:   Parameter 1:</span>
<span class="cm">(stdin):30:3: error: cannot access private member n</span>
<span class="cm">(stdin):31:3: Calling function &#39;report&#39;:</span>
<span class="cm">(stdin):31:10:   Parameter 1:</span>
<span class="cm">(stdin):31:3: error: cannot access protected member s</span>
<span class="cm">(stdin):33:3: error: cannot access protected function A.bar?()</span>
<span class="cm">(stdin):22:3: Calling function &#39;report&#39;:</span>
<span class="cm">(stdin):22:10:   Parameter 1:</span>
<span class="cm">(stdin):22:3: error: cannot access private member n</span>


<span class="cm">*/</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">permits</span></code> キーワードの使用により、構造体もしくはオブジェクトがこのメカニズムを迂回させることができます。構造体やオブジェクトが、他の構造体もしくはオブジェクトの <code class="docutils literal"><span class="pre">permits</span></code> セクションにリストされていれば、private や protected メンバもしくはメソッドにアクセス可能です。</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** Example: Bypassing Acess Controls Using ``permits``</span>
<span class="cm">*/</span>

<span class="kr">object</span> <span class="nx">A</span><span class="p">;</span>

<span class="kr">object</span> <span class="nx">Base</span> <span class="k">permits</span> <span class="nx">A</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="kr">UInt32</span> <span class="nx">n</span><span class="p">;</span>
<span class="p">};</span>

<span class="kr">object</span> <span class="nx">A</span> <span class="p">{</span> <span class="nx">Base</span> <span class="nx">b</span><span class="p">;</span> <span class="p">};</span>
<span class="nx">A</span><span class="p">()</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="nx">Base</span><span class="p">();</span> <span class="p">}</span>
<span class="nx">A</span><span class="p">.</span><span class="nx">foo</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">n</span><span class="p">);</span> <span class="c1">// OK since Base permits A</span>
<span class="p">}</span>

<span class="kr">object</span> <span class="nx">B</span><span class="p">;</span>
<span class="kr">object</span> <span class="nx">C</span><span class="p">;</span>

<span class="kr">object</span> <span class="nx">Derived</span> <span class="o">:</span> <span class="nx">Base</span> <span class="k">permits</span> <span class="nx">B</span><span class="p">,</span> <span class="nx">C</span>
<span class="p">{</span>
<span class="p">};</span>

<span class="k">private</span> <span class="nx">Derived</span><span class="p">.</span><span class="nx">bar</span><span class="p">()</span> <span class="p">{}</span>

<span class="kr">object</span> <span class="nx">B</span> <span class="p">{</span> <span class="nx">Derived</span> <span class="nx">d</span><span class="p">;</span> <span class="p">};</span>
<span class="nx">B</span><span class="p">()</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">d</span> <span class="o">=</span> <span class="nx">Derived</span><span class="p">();</span> <span class="p">}</span>
<span class="nx">B</span><span class="p">.</span><span class="nx">baz</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">d</span><span class="p">.</span><span class="nx">bar</span><span class="p">();</span>  <span class="c1">// OK since Derived permits B</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nx">A</span> <span class="nx">a</span><span class="p">();</span>
  <span class="nx">a</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>
  <span class="nx">B</span> <span class="nx">b</span><span class="p">();</span>
  <span class="nx">b</span><span class="p">.</span><span class="nx">baz</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">0</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="interfaces-and-inheritance">
<span id="klpg-interfaces-inheritance"></span><h4>インタフェースと継承<a class="headerlink" href="#interfaces-and-inheritance" title="このヘッドラインへのパーマリンク">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.13.0 で追加.</span></p>
</div>
<p><a class="reference internal" href="#kplg-object-inheritance"><span>base object type</span></a> を継承し特殊化したオブジェクトでも追加のインタフェースを実装できます。</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="kr">object</span> <span class="nx">MyObj</span> <span class="o">:</span> <span class="nx">MyBaseObj</span><span class="p">,</span> <span class="nx">MyInt</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>基底オブジェクトがインタフェースを実装していると、そのオブジェクトを継承し特殊化したオブジェクトからも、基底オブジェクトでそのインタフェースを実装したメソッドをさらに、 <cite>override</cite> した実装が使用可能です。このような場面では、特別なシンタックスが必要となります。同一のインタフェースを実装した基底クラスのメソッドを呼ぶには <a class="reference internal" href="globals.html#klpg-method-interface-inheritance"><span>Interface methods and inheritance</span></a> 参照してください。</p>
</div>
<div class="section" id="forward-declaration-of-objects-and-interfaces">
<span id="klpg-forward-declarations"></span><h4>オブジェクト、インタフェースの前方宣言<a class="headerlink" href="#forward-declaration-of-objects-and-interfaces" title="このヘッドラインへのパーマリンク">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.12.0 で追加: </span>オブジェクト、インタフェースの前方宣言</p>
</div>
<p>オブジェクトやインタフェースの存在を、実際のメンバの定義抜きに宣言できます。オブジェクトやインタフェースが相互依存するような場合便利です。オブジェクトやインタフェースの前方定義するには、単にメンバやメソッドそしてインタフェースの実装を省略します。</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** Example: Forward Declaration of Objects and Interfaces</span>
<span class="cm">*/</span>

<span class="c1">// Forward delcaration of interface IntTwo</span>
<span class="kr">interface</span> <span class="nx">IntTwo</span><span class="p">;</span>

<span class="kr">interface</span> <span class="nx">IntOne</span> <span class="p">{</span>
  <span class="nx">add</span><span class="o">!</span><span class="p">(</span><span class="nx">IntTwo</span> <span class="nx">int</span><span class="p">);</span>
<span class="p">};</span>

<span class="kr">interface</span> <span class="nx">IntTwo</span> <span class="p">{</span>
  <span class="nx">sub</span><span class="o">!</span><span class="p">(</span><span class="nx">IntOne</span> <span class="nx">int</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// Forward delcaration of object ObjTwo</span>
<span class="kr">object</span> <span class="nx">ObjTwo</span><span class="p">;</span>

<span class="kr">object</span> <span class="nx">ObjOne</span> <span class="o">:</span> <span class="nx">IntOne</span><span class="p">,</span> <span class="nx">IntTwo</span> <span class="p">{</span>
  <span class="kr">UInt32</span> <span class="nx">a</span><span class="p">;</span>
  <span class="nx">ObjTwo</span> <span class="nx">objTwo</span><span class="p">;</span>
<span class="p">};</span>

<span class="kr">object</span> <span class="nx">ObjTwo</span> <span class="p">{</span>
  <span class="nx">ObjOne</span> <span class="nx">objOne</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">ObjOne</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">ObjOne</span><span class="p">.</span><span class="nx">add</span><span class="o">!</span><span class="p">(</span><span class="nx">IntTwo</span> <span class="nx">intTwo</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">ObjOne</span> <span class="nx">objOne</span> <span class="o">=</span> <span class="nx">ObjOne</span><span class="p">(</span><span class="nx">intTwo</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">+=</span> <span class="nx">objOne</span><span class="p">.</span><span class="nx">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">ObjOne</span><span class="p">.</span><span class="nx">sub</span><span class="o">!</span><span class="p">(</span><span class="nx">IntOne</span> <span class="nx">intOne</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">ObjOne</span> <span class="nx">objOne</span> <span class="o">=</span> <span class="nx">ObjOne</span><span class="p">(</span><span class="nx">intOne</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">-=</span> <span class="nx">objOne</span><span class="p">.</span><span class="nx">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">ObjOne</span> <span class="nx">objOne</span><span class="p">();</span>
  <span class="nx">objOne</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span> <span class="nx">IntOne</span><span class="p">(</span><span class="nx">objOne</span><span class="p">)</span> <span class="p">);</span>
  <span class="nx">objOne</span><span class="p">.</span><span class="nx">sub</span><span class="p">(</span> <span class="nx">IntTwo</span><span class="p">(</span><span class="nx">objOne</span><span class="p">)</span> <span class="p">);</span>
  <span class="nx">objOne</span><span class="p">.</span><span class="nx">objTwo</span> <span class="o">=</span> <span class="nx">ObjTwo</span><span class="p">();</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">objOne</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">{a:0,objTwo:{objOne:null}}</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="unowned-object-and-interface-references">
<span id="unowned-object-references"></span><h4>未所有オブジェクト、インタフェースへの参照<a class="headerlink" href="#unowned-object-and-interface-references" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>オブジェクト、インタフェースへの参照全てを追跡するランタイムコストはとても高価となりえます。特定の状況、例えばオブジェクトへの参照が常に1つ以上あることが事前に判明している時などは、パフォーマンス上の理由からこの追跡を避けるのが望ましいです。KLでは <code class="samp docutils literal"><span class="pre">Ref&lt;</span><em><span class="pre">ObjectType</span></em><span class="pre">&gt;</span></code>, <code class="samp docutils literal"><span class="pre">Ref&lt;</span><em><span class="pre">InterfaceType</span></em><span class="pre">&gt;</span></code> 構文を使いこの状況を避けることができます。これにより、メモリリークを発生させず、オブジェクトやインタフェースの参照を繰り返し作成する機能を提供します。</p>
<p>未所有参照（Unowned reference）は通常のオブジェクトやインタフェースの参照と全く同様に動作します。ただひとつの違いは、参照を追跡しないことです。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">未所有参照の使用すると、細かいバグにより、クラッシュを非常に簡単に引き起こしてしまいます。使用はあなたの責任です。未所有参照が、他の何かが所有するオブジェクトを正しく確実に参照するようにしましょう。つまり、既に破棄されたオブジェクトを参照する未所有参照をそのまま放置することができてしまい、プログラム中からその参照を使用し何かさせようとするとクラッシュしてしまうのです。</p>
</div>
<p>未所有参照の使用例：</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** Example: Unowned References</span>
<span class="cm">*/</span>

<span class="kr">object</span> <span class="nx">Foo</span> <span class="p">{</span>
  <span class="kr">SInt32</span> <span class="nx">intMember</span><span class="p">;</span>
  <span class="kr">String</span> <span class="nx">stringMember</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Foo</span> <span class="nx">foo</span><span class="p">();</span> <span class="c1">// Construct a new specific object</span>
  <span class="nx">foo</span><span class="p">.</span><span class="nx">stringMember</span> <span class="o">=</span> <span class="s2">&quot;me!&quot;</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;foo = &quot;</span> <span class="o">+</span> <span class="nx">foo</span><span class="p">);</span>
  <span class="nx">Ref</span><span class="o">&lt;</span><span class="nx">Foo</span><span class="o">&gt;</span> <span class="nx">fooRef</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">;</span> <span class="c1">// fooRef is an unowned reference to foo</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;fooRef = &quot;</span> <span class="o">+</span> <span class="nx">fooRef</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">foo = {intMember:0,stringMember:&quot;me!&quot;}</span>
<span class="cm">fooRef = {intMember:0,stringMember:&quot;me!&quot;}</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="the-type-type">
<span id="klpg-types-type"></span><h4><code class="code docutils literal"><span class="pre">Type</span></code> 型<a class="headerlink" href="#the-type-type" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>KLには <code class="code docutils literal"><span class="pre">Type</span></code> 型と呼ばれる特別な型があります。KLでのある値の型を表します。KLでの全ての値は <code class="code docutils literal"><span class="pre">{value}.type()</span></code> メソッドをサポートします。これによりそのオブジェクトの型、 <code class="code docutils literal"><span class="pre">Type</span></code>　型の値を得ます。</p>
<p>変数の <code class="code docutils literal"><span class="pre">Type</span></code> のディフォルト値は、特別な値 <code class="code docutils literal"><span class="pre">None</span></code> です。これはいかに説明する幾つかのメソッドの返り値でもあります。 <code class="code docutils literal"><span class="pre">None</span></code> はどの <code class="code docutils literal"><span class="pre">{value}</span></code> に対する <code class="code docutils literal"><span class="pre">{value}.type()</span></code> とも等しくありません。</p>
<p><code class="code docutils literal"><span class="pre">Type</span></code> 型の値をつかい、いくつかできることがあります。おもに、インタフェースとオブジェクトの実行時型推論に用います。</p>
<ul>
<li><p class="first">まず値の型を参照し <code class="code docutils literal"><span class="pre">Type</span></code> 型の値を参照し、そして比較に使用することができます：</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** Example: Type Comparisons</span>
<span class="cm">*/</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nx">Type</span> <span class="nx">booleanType</span> <span class="o">=</span> <span class="kr">Boolean</span><span class="p">;</span>
  <span class="kr">UInt32</span> <span class="nx">uint32</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;booleanType == uint32.type&quot;</span> <span class="o">+</span> <span class="nx">booleanType</span> <span class="o">==</span> <span class="nx">uint32</span><span class="p">.</span><span class="nx">type</span><span class="p">);</span>
  <span class="kr">Boolean</span> <span class="nx">boolean</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;booleanType == boolean.type&quot;</span> <span class="o">+</span> <span class="nx">booleanType</span> <span class="o">==</span> <span class="nx">boolean</span><span class="p">.</span><span class="nx">type</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>
<span class="cm">(stdin):10:3: warning: must use parentheses to call methods (deprecation; will become an error in next version)</span>

<span class="cm">false</span>
<span class="cm">false</span>

<span class="cm">*/</span>
</pre></div>
</div>
</li>
<li><p class="first"><a class="reference internal" href="#klpg-types-interfaces"><span>インタフェース（Interfaces）</span></a> では <code class="code docutils literal"><span class="pre">{value}.type()</span></code> メソッドで、生成されたオブジェクトが参照する特定オブジェクトの型を返します。これによりオブジェクトの型推論を行います。 <a class="reference internal" href="#klpg-types-interfaces"><span>インタフェース（Interfaces）</span></a> 節に詳細があります。</p>
</li>
<li><p class="first"><code class="code docutils literal"><span class="pre">Type</span></code> 型の値は <code class="code docutils literal"><span class="pre">{value}.parentType()</span></code> メソッドをサポートします。この場合 <code class="code docutils literal"><span class="pre">{value}</span></code> は親を継承したオブジェクトもしくは構造体です。 <code class="code docutils literal"><span class="pre">parentType()</span></code> は親の型を返します。未継承であれば <code class="code docutils literal"><span class="pre">parentType()</span></code> <code class="code docutils literal"><span class="pre">None</span></code> を返します。</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** Example: parentType</span>
<span class="cm">*/</span>

<span class="kr">object</span> <span class="nx">Obj</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>
<span class="kr">object</span> <span class="nx">SubObj</span> <span class="o">:</span> <span class="nx">Obj</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Type</span> <span class="nx">type</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;type = &quot;</span> <span class="o">+</span> <span class="nx">type</span> <span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;type.parentType() = &quot;</span> <span class="o">+</span> <span class="nx">type</span><span class="p">.</span><span class="nx">parentType</span><span class="p">());</span>
  <span class="nx">type</span> <span class="o">=</span> <span class="nx">Obj</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;type = &quot;</span> <span class="o">+</span> <span class="nx">type</span> <span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;type.parentType() = &quot;</span> <span class="o">+</span> <span class="nx">type</span><span class="p">.</span><span class="nx">parentType</span><span class="p">());</span>
  <span class="nx">type</span> <span class="o">=</span> <span class="nx">SubObj</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;type = &quot;</span> <span class="o">+</span> <span class="nx">type</span> <span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;type.parentType() = &quot;</span> <span class="o">+</span> <span class="nx">type</span><span class="p">.</span><span class="nx">parentType</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">type = None</span>
<span class="cm">type.parentType() = None</span>
<span class="cm">type = Obj</span>
<span class="cm">type.parentType() = None</span>
<span class="cm">type = SubObj</span>
<span class="cm">type.parentType() = Obj</span>

<span class="cm">*/</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="code docutils literal"><span class="pre">Type</span></code> 型の値は <code class="code docutils literal"><span class="pre">{value}.isA({interfaceType})</span></code> メソッドをサポートします。 <code class="code docutils literal"><span class="pre">{value}</span></code> がインタフェース <code class="code docutils literal"><span class="pre">{interfaceType}</span></code> をサポートしている場合のみ <code class="code docutils literal"><span class="pre">true</span></code> を返します。</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** Example: isA</span>
<span class="cm">*/</span>

<span class="kr">interface</span> <span class="nx">Int1</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>
<span class="kr">interface</span> <span class="nx">Int2</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>
<span class="kr">interface</span> <span class="nx">Int3</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>
<span class="kr">object</span> <span class="nx">Obj</span> <span class="o">:</span> <span class="nx">Int1</span><span class="p">,</span> <span class="nx">Int2</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>
<span class="kr">object</span> <span class="nx">SubObj</span> <span class="o">:</span> <span class="nx">Obj</span><span class="p">,</span> <span class="nx">Int3</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Type</span> <span class="nx">nullType</span><span class="p">;</span>
  <span class="nx">Obj</span> <span class="nx">obj</span><span class="p">();</span>
  <span class="nx">SubObj</span> <span class="nx">subObj</span><span class="p">();</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;nullType.isA(nullType) = &quot;</span> <span class="o">+</span> <span class="nx">nullType</span><span class="p">.</span><span class="nx">isA</span><span class="p">(</span><span class="nx">nullType</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;nullType.isA(Obj) = &quot;</span> <span class="o">+</span> <span class="nx">nullType</span><span class="p">.</span><span class="nx">isA</span><span class="p">(</span><span class="nx">Obj</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;nullType.isA(SubObj) = &quot;</span> <span class="o">+</span> <span class="nx">nullType</span><span class="p">.</span><span class="nx">isA</span><span class="p">(</span><span class="nx">SubObj</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;nullType.isA(Int1) = &quot;</span> <span class="o">+</span> <span class="nx">nullType</span><span class="p">.</span><span class="nx">isA</span><span class="p">(</span><span class="nx">Int1</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;nullType.isA(Int2) = &quot;</span> <span class="o">+</span> <span class="nx">nullType</span><span class="p">.</span><span class="nx">isA</span><span class="p">(</span><span class="nx">Int2</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;nullType.isA(Int3) = &quot;</span> <span class="o">+</span> <span class="nx">nullType</span><span class="p">.</span><span class="nx">isA</span><span class="p">(</span><span class="nx">Int3</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;obj.type.isA(nullType) = &quot;</span> <span class="o">+</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">type</span><span class="p">.</span><span class="nx">isA</span><span class="p">(</span><span class="nx">nullType</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;obj.type.isA(Obj) = &quot;</span> <span class="o">+</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">type</span><span class="p">.</span><span class="nx">isA</span><span class="p">(</span><span class="nx">Obj</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;obj.type.isA(SubObj) = &quot;</span> <span class="o">+</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">type</span><span class="p">.</span><span class="nx">isA</span><span class="p">(</span><span class="nx">SubObj</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;obj.type.isA(Int1) = &quot;</span> <span class="o">+</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">type</span><span class="p">.</span><span class="nx">isA</span><span class="p">(</span><span class="nx">Int1</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;obj.type.isA(Int2) = &quot;</span> <span class="o">+</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">type</span><span class="p">.</span><span class="nx">isA</span><span class="p">(</span><span class="nx">Int2</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;obj.type.isA(Int3) = &quot;</span> <span class="o">+</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">type</span><span class="p">.</span><span class="nx">isA</span><span class="p">(</span><span class="nx">Int3</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;subObj.type.isA(nullType) = &quot;</span> <span class="o">+</span> <span class="nx">subObj</span><span class="p">.</span><span class="nx">type</span><span class="p">.</span><span class="nx">isA</span><span class="p">(</span><span class="nx">nullType</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;subObj.type.isA(Obj) = &quot;</span> <span class="o">+</span> <span class="nx">subObj</span><span class="p">.</span><span class="nx">type</span><span class="p">.</span><span class="nx">isA</span><span class="p">(</span><span class="nx">Obj</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;subObj.type.isA(SubObj) = &quot;</span> <span class="o">+</span> <span class="nx">subObj</span><span class="p">.</span><span class="nx">type</span><span class="p">.</span><span class="nx">isA</span><span class="p">(</span><span class="nx">SubObj</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;subObj.type.isA(Int1) = &quot;</span> <span class="o">+</span> <span class="nx">subObj</span><span class="p">.</span><span class="nx">type</span><span class="p">.</span><span class="nx">isA</span><span class="p">(</span><span class="nx">Int1</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;subObj.type.isA(Int2) = &quot;</span> <span class="o">+</span> <span class="nx">subObj</span><span class="p">.</span><span class="nx">type</span><span class="p">.</span><span class="nx">isA</span><span class="p">(</span><span class="nx">Int2</span><span class="p">));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;subObj.type.isA(Int3) = &quot;</span> <span class="o">+</span> <span class="nx">subObj</span><span class="p">.</span><span class="nx">type</span><span class="p">.</span><span class="nx">isA</span><span class="p">(</span><span class="nx">Int3</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>
<span class="cm">(stdin):22:3: warning: must use parentheses to call methods (deprecation; will become an error in next version)</span>

<span class="cm">nullType.isA(nullType) = false</span>
<span class="cm">nullType.isA(Obj) = false</span>
<span class="cm">nullType.isA(SubObj) = false</span>
<span class="cm">nullType.isA(Int1) = false</span>
<span class="cm">nullType.isA(Int2) = false</span>
<span class="cm">nullType.isA(Int3) = false</span>
<span class="cm">obj.type.isA(nullType) = false</span>
<span class="cm">obj.type.isA(Obj) = true</span>
<span class="cm">obj.type.isA(SubObj) = false</span>
<span class="cm">obj.type.isA(Int1) = true</span>
<span class="cm">obj.type.isA(Int2) = true</span>
<span class="cm">obj.type.isA(Int3) = false</span>
<span class="cm">subObj.type.isA(nullType) = false</span>
<span class="cm">subObj.type.isA(Obj) = true</span>
<span class="cm">subObj.type.isA(SubObj) = true</span>
<span class="cm">subObj.type.isA(Int1) = true</span>
<span class="cm">subObj.type.isA(Int2) = true</span>
<span class="cm">subObj.type.isA(Int3) = true</span>

<span class="cm">*/</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="code docutils literal"><span class="pre">{typeValue}.jsonDesc()</span></code> メソッドにより、型の説明を取得できます。実行時に構造体のメンバのようなものを探しだすことができます。</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** Example: Type Description</span>
<span class="cm">*/</span>

<span class="kr">struct</span> <span class="nx">S</span>
<span class="p">{</span>
  <span class="kr">String</span> <span class="nx">string</span><span class="p">;</span>
  <span class="kr">UInt32</span> <span class="nx">uint32</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">S</span><span class="p">.</span><span class="nx">jsonDesc</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">{</span>
<span class="cm">  &quot;name&quot; : &quot;S&quot;,</span>
<span class="cm">  &quot;size&quot; : 32,</span>
<span class="cm">  &quot;owningExt&quot; : null,</span>
<span class="cm">  &quot;members&quot; : [</span>
<span class="cm">    {</span>
<span class="cm">      &quot;name&quot; : &quot;string&quot;,</span>
<span class="cm">      &quot;type&quot; : &quot;String&quot;</span>
<span class="cm">      },</span>
<span class="cm">    {</span>
<span class="cm">      &quot;name&quot; : &quot;uint32&quot;,</span>
<span class="cm">      &quot;type&quot; : &quot;UInt32&quot;</span>
<span class="cm">      }</span>
<span class="cm">    ]</span>
<span class="cm">  }</span>

<span class="cm">*/</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="objects-versus-structures">
<span id="klpg-objects-versus-structures"></span><span id="index-15"></span><h4>オブジェクト vs 構造体<a class="headerlink" href="#objects-versus-structures" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>型の合成に、構造体をつかうかオブジェクトを使うかの決定は、実行時の動作や性能に対してだけではなく、プログラムの設計にも影響する極めて重要な選択です。</p>
<p>構造体は、通常、パフォーマンスクリティカルな小さな型に対して最善な選択です。与えられた型の値を一時的に大量に作成する、複雑な式の場合、オブジェクトではなく、構造体を使いましょう。1点致命的なパフォーマンスの観点は、構造体の型をもった変数は、プログラム「スタック」に確保されるということです。つまり、構造体ではメモリ確保、開放のオーバーヘッドが事実上存在しないことを意味します。例えば、ベクタやトランスフォーム型などの数学的な型は、通常構造体です。</p>
<p>オブジェクトは、通常、使用回数が作成／破棄よりも著しく多いような、大規模な型に対して最善の選択です。オブジェクトは、スタックよりも顕著に遅い「ヒープ」に確保されます。さらに、異なる沢山の変数が同じオブジェクトを指すことができ、オブジェクトは同じデータに対し沢山参照する場合、とても良い選択です。データ階層などは通常オブジェクトで表現します。</p>
</div>
</div>
<div class="section" id="arrays">
<span id="index-16"></span><span id="id1"></span><h3>配列<a class="headerlink" href="#arrays" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><em class="dfn">array</em> とは同型（配列の <em class="dfn">element type</em> 呼ばれる)の値を集めた一連のシーケンスです。整数によって索引付け（インデックス）され、メモリ上に連続配置されます。KLでは３種類の配列をサポートします: 可変長配列（variable-size arrays）, 固定長配列（fixed-length arrays）,外部配列（external arrays）です。各配列の詳細については後述します。</p>
<p id="array-properties">３つのうちいずれであっても、KLにおける配列は幾つかの共通の振舞をもちます。</p>
<ul>
<li><p class="first">配列は <code class="docutils literal"><span class="pre">[..]</span></code> 演算子をつかい索引付されます。JavaScriptやC言語と同一です。配列の索引は 0 基点です。これもJavaScriptやC言語と一緒です:</p>
<div class="highlight-python"><div class="highlight"><pre>Size values[];    // Declare a variable-size array
values.push(42);  // Push some elements onto the end of the array
values.push(21);
values.push(3);
report(values[1]); // outputs &quot;21&quot;
</pre></div>
</div>
</li>
<li><p class="first">配列のサイズの型は <code class="docutils literal"><span class="pre">Size</span></code> 型です。インデクシング演算子は、 <code class="docutils literal"><span class="pre">Index</span></code> 型（ <code class="docutils literal"><span class="pre">Size</span></code> へのエイリアス）を取ります。</p>
</li>
<li><p class="first">配列の宣言はネスト（入れ子）可能です、さらに他の配列の型ともネストできます。</p>
<div class="highlight-python"><div class="highlight"><pre>Integer b[][];  // A variable-size array of variable-size arrays of integers
Boolean a[2][]; // An array of 2 variable-size arrays of booleans
String c&lt;&gt;[];   // An external array of variable-size arrays of strings
</pre></div>
</div>
</li>
<li><p class="first">配列は参照渡し（ <em class="dfn">passed by reference</em> ）により関数やオペレータに渡ります。すなわち、コピーされません。このことは、100万要素を持つ１つの配列を関数に渡すのも、1つの要素の1つの配列を渡すのも、かかる時間は同じです。</p>
</li>
<li><p class="first">Fabricクライアントを境界チェック（bounds-checks)を有効にし実行した場合、インデクシング演算子を使った配列へのインデクシングは、境界チェックされます。インデックスが配列の終端に達し、超えると、例外が投げられます。</p>
</li>
</ul>
<div class="section" id="variable-size-arrays">
<span id="variable-arrays"></span><span id="index-17"></span><h4>可変長配列（Variable-Size Arrays）<a class="headerlink" href="#variable-size-arrays" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><em class="dfn">variable-size array</em> とは、実行時に長さを帰ることのできる配列です。可変長配列の宣言は変数（パラメータもしくは構造体メンバが宣言された）の名前の直後 <code class="docutils literal"><span class="pre">[]</span></code> を付与します。例： <code class="docutils literal"><span class="pre">String</span> <span class="pre">strings[]</span></code></p>
<p>可変長配列は <a class="reference internal" href="#array-properties"><span>properties of arrays</span></a> を全て持ち、さらに以下の追加の特徴があります：</p>
<ul class="simple">
<li><p class="first">可変長配列の最大サイズは <span class="math">\(2^{31}-1\)</span></p>
</li>
<li><p class="first">可変長配列は、割り当て共有（ <em class="dfn">share-on-assign</em> ）です。つまりある可変長配列を他の配列へ割り当てると、要素はコピーされるのでは「なく」、要素への「参照をコピー」します。片方の配列へのどのような変更も、もう片方の配列に影響します。これはシャローコピー（対義語はディープコピー）と呼ばれます。配列のディープコピーを行うには、後述する <code class="docutils literal"><span class="pre">clone()</span></code>  メソッドを使用します。</p>
</li>
<li><p class="first">可変長配列は、以下のメソッド、関数をサポートします。</p>
<ul>
<li><p class="first">ディフォルトで可変長配列は空です。コンストラクト時に整数を与えた場合、その配列初期化時初めからは要素を複数持つことになります。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">push(element)</span></code> メソッドにより、末端に要素を追加します。結果配列サイズは１繰り上がります。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">pop()</span></code> メソッドにより、末端要素を取り除き、その要素を返します。結果配列サイズは１小さくなります。空の配列に対し <code class="docutils literal"><span class="pre">pop()</span></code> を呼ぶとエラーが返ります。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">size()</span></code> メソッドによりその可変長配列の要素数を返します。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">resize(newSize)</span></code> メソッドにより配列のサイズを変更します。末端新規要素を、その要素の型のディフォルト値で初期化します。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">reserve(count)</span></code> メソッドでは少なくとも <code class="docutils literal"><span class="pre">count</span></code> 分の要素の場が確保されていることを保証します。事前に要素の最終的な数がわかっているのであれば、<code class="docutils literal"><span class="pre">push(...)</span></code> を何度も呼ぶ前に <code class="docutils literal"><span class="pre">reserve(...)</span></code> すると速度面で優位になります。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">clone()</span></code> メソッドによりその可変長配列のディープコピーを作成します。結果のコピー物は初期状態で他の可変長配列から共有されていません。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">swap(Size</span> <span class="pre">lhsIndex,</span> <span class="pre">Size</span> <span class="pre">rhsIndex)</span></code> メソッドにより、２つのインデクスにより指定された配列の値を入れ替えます。</p>
</li>
<li><p class="first"><code class="samp docutils literal"><span class="pre">swap(</span><em><span class="pre">Type</span></em> <span class="pre">lhs[],</span> <em><span class="pre">Type</span></em> <span class="pre">rhs[])</span></code> 関数により、２つの可変長配列の内容を入れ替えます。この操作はデータのコピーを伴わず、一定時間で完了します。</p>
</li>
</ul>
</li>
</ul>
<div class="highlight-kl"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** Example: Variable-Size Arrays</span>
<span class="cm">*/</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">Integer</span> <span class="nx">a</span><span class="p">[];</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;The array a has size &quot;</span> <span class="o">+</span> <span class="nx">a</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot; and value &quot;</span> <span class="o">+</span> <span class="nx">a</span><span class="p">);</span>
  <span class="nx">a</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
  <span class="nx">a</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">84</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;The array NOW has size &quot;</span> <span class="o">+</span> <span class="nx">a</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot; and value &quot;</span> <span class="o">+</span> <span class="nx">a</span><span class="p">);</span>
  <span class="nx">a</span><span class="p">.</span><span class="nx">resize</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;The array NOW has size &quot;</span> <span class="o">+</span> <span class="nx">a</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot; and value &quot;</span> <span class="o">+</span> <span class="nx">a</span><span class="p">);</span>
  <span class="kr">String</span> <span class="nx">b</span><span class="p">[](</span><span class="mi">4</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;b is initially &quot;</span> <span class="o">+</span> <span class="nx">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">The array a has size 0 and value []</span>
<span class="cm">The array NOW has size 2 and value [42,84]</span>
<span class="cm">The array NOW has size 4 and value [42,84,0,0]</span>
<span class="cm">b is initially [&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;]</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="fixed-size-arrays">
<span id="fixed-arrays"></span><span id="index-18"></span><h4>固定長配列（Fixed-Size Arrays）<a class="headerlink" href="#fixed-size-arrays" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>A <em class="dfn">fixed-size array</em> is an array whose size is fixed at runtime.  Fixed-size arrays have much faster performance characteristics than variable-size arrays, therefore should be used in place of variable-sized arrays when the size of an array is known at compile time.  Fixed-size arrays are declared by appending <code class="samp docutils literal"><span class="pre">[</span><em><span class="pre">size</span></em><span class="pre">]</span></code> to the name of the variable, parameter or structure member where they are declared, eg. <code class="docutils literal"><span class="pre">String</span> <span class="pre">strings[4]</span></code>.</p>
<p>Fixed-size arrays have all the <a class="reference internal" href="#array-properties"><span>properties of arrays</span></a> as well as the following additional properties:</p>
<ul>
<li><p class="first">The maximum size of a fixed-size array is <span class="math">\(2^31-1\)</span>.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">Since fixed-size arrays are allocated on the stack (instead of the heap), using very large fixed-size arrays may result in a stack overflow.  It is recommended that fixed-size arrays only be used for arrays that are reasonably small.</p>
</div>
</li>
<li><p class="first">Fixed-size arrays are copied when they are assigned, ie. they are <em class="dfn">copy-by-value</em>.</p>
</li>
</ul>
<div class="highlight-kl"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** Example: Fixed-Size Arrays</span>
<span class="cm">*/</span>

<span class="kd">function</span> <span class="kr">Float32</span> <span class="nx">det</span><span class="p">(</span><span class="kr">Float32</span> <span class="nx">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nx">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nx">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nx">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">Float32</span> <span class="nx">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
  <span class="nx">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.5</span><span class="p">;</span>
  <span class="nx">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">9.2</span><span class="p">;</span>
  <span class="nx">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.1</span><span class="p">;</span>
  <span class="nx">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">8.6</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;The determinant of &quot;</span> <span class="o">+</span> <span class="nx">mat</span> <span class="o">+</span> <span class="s2">&quot; is &quot;</span> <span class="o">+</span> <span class="nx">det</span><span class="p">(</span><span class="nx">mat</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">The determinant of [[+3.5,-9.2],[-2.1,+8.6]] is +10.78</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="external-arrays">
<span id="index-19"></span><span id="id2"></span><h4>External Arrays<a class="headerlink" href="#external-arrays" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>An <em class="dfn">external array</em> is an array whose size is fixed when it is created and does not own the data is operates on.  External arrays are primarily used for operator parameters bound to sliced data inside a Fabric Engine dependency graph as well as arrays bound to external data within Fabric Engine extensions, but they can also be used on their own within KL.  External arrays are declared by appending <code class="docutils literal"><span class="pre">&lt;&gt;</span></code> to the name of the variable, parameter or structure member where they are declared, eg. <code class="docutils literal"><span class="pre">String</span> <span class="pre">strings&lt;&gt;</span></code>.</p>
<p>External arrays have all the <a class="reference internal" href="#array-properties"><span>properties of arrays</span></a> as well as the following additional properties:</p>
<ul>
<li><p class="first">An external array can be constructed from an existing variable array.  This simply points the external array to the data within the variable array at the time the variable array is constructed.  Note however that there are lots of ways that this usage can break, such as through resizing the variable array.  This usage is primarily meant for testing:</p>
<div class="highlight-python"><div class="highlight"><pre>String va[];
va.push(&quot;hello&quot;);
String ea&lt;&gt;(va);
report(ea); // prints [&quot;hello&quot;]
</pre></div>
</div>
</li>
<li><p class="first">External arrays support an empty constructor (which constructs an empty external array):</p>
<div class="highlight-python"><div class="highlight"><pre>Size ea&lt;&gt;;
report(ea); // prints []
</pre></div>
</div>
</li>
<li><p class="first">External arrays support a copy constructor and an assignment operator, both of which simply make one external array refer to the same data as the other:</p>
<div class="highlight-python"><div class="highlight"><pre>String va[];
va.push(&quot;hello&quot;);
String ea1&lt;&gt;(va);
String ea2&lt;&gt;(ea1);
report(ea2); // prints [&quot;hello&quot;]
String ea3&lt;&gt;;
ea3 = ea2;
report(ea3); // prints [&quot;hello&quot;]
</pre></div>
</div>
</li>
<li><p class="first">External arrays support a <code class="docutils literal"><span class="pre">size()</span></code> method that returns the number of elements in the external array.</p>
</li>
<li><p class="first">External arrays can be initialized given a <code class="docutils literal"><span class="pre">data</span></code> pointer as well as a <code class="docutils literal"><span class="pre">size</span></code>. This allows you to map arbitrary memory as an array. This is very useful especially when passing data from C++ into KL and back out. You can also use this constructor to reinterpret any memory as an array:</p>
<div class="highlight-python"><div class="highlight"><pre>Float32 floats[12];
for(Size i=0; i&lt;floats.size(); i++)
  floats[i] = Float32(i);

Vec3 vectors&lt;&gt;(floats.data(), floats.size() / 3);
report(vectors);
</pre></div>
</div>
</li>
<li><p class="first">As opposed to variable arrays, External arrays are not ref counted objects. This makes them cheaper to pass around, but can&#8217;t be used to manage the lifetime of memory. (See next point)</p>
</li>
<li><p class="first">External arrays do not manage the lifetime of the data they operate on. A variable array will free its memory when it is destroyed, but an external array is simply a mapping to memory owned by something else. An external array should never out-live the owner of the data, else it will map to garbage data:</p>
<div class="highlight-python"><div class="highlight"><pre>String ea&lt;&gt;;
{
  String va[];
  for(Integer i=0; i&lt;2023; i++)
    va.push(&quot;hello:&quot; + i);
  String ea1&lt;&gt;(va);
  ea = ea1;
  // At the end of this scope, the variable array is freed, along with its data.
}
// The memory of the variable array is now garbage because it has been destroyed.
// Printing the data will return garbage data or crash KL.
// External arrays must be used with care to avoid mapping to garbage data in this way.
report(ea);
</pre></div>
</div>
</li>
</ul>
<p>The following is an example of using external arrays:</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** Example: External Arrays</span>
<span class="cm">*/</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">String</span> <span class="nx">va</span><span class="p">[];</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">Size</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span>
    <span class="nx">va</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&quot;string &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>

  <span class="kr">String</span> <span class="nx">strings</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="nx">va</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">Size</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span>
    <span class="nx">strings</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+=</span> <span class="s2">&quot; appended&quot;</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;strings = &quot;</span> <span class="o">+</span> <span class="nx">strings</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;va = &quot;</span> <span class="o">+</span> <span class="nx">va</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">strings = [&quot;string 1 appended&quot;,&quot;string 2 appended&quot;,&quot;string 3 appended&quot;,&quot;string 4 appended&quot;,&quot;string 5 appended&quot;,&quot;string 6 appended&quot;,&quot;string 7 appended&quot;,&quot;string 8 appended&quot;]</span>
<span class="cm">va = [&quot;string 1 appended&quot;,&quot;string 2 appended&quot;,&quot;string 3 appended&quot;,&quot;string 4 appended&quot;,&quot;string 5 appended&quot;,&quot;string 6 appended&quot;,&quot;string 7 appended&quot;,&quot;string 8 appended&quot;]</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="dictionaries">
<span id="index-20"></span><span id="id3"></span><h3>Dictionaries<a class="headerlink" href="#dictionaries" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>KL supports key-value pair <em class="dfn">dictionaries</em>.  The type of the key of a dictionary can be any of the KL base types (e.g. <code class="code docutils literal"><span class="pre">Boolean</span></code>, <code class="docutils literal"><span class="pre">String</span></code>, or any integer or floating-point type) as well as custom types for which a special <code class="samp docutils literal"><span class="pre">.hash</span></code> method has been defined (see <a class="reference internal" href="#klpg-dictionaries-custom-key-types"><span>Dictionaries Using Custom Key Types</span></a>) and the type of the value can be any type.  Dictionaries are declared by appending <code class="samp docutils literal"><span class="pre">[</span><em><span class="pre">KeyType</span></em><span class="pre">]</span></code> to the variable, parameter or member name.  For example:</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="kr">String</span> <span class="nx">scalarToString</span><span class="p">[</span><span class="kr">Float32</span><span class="p">];</span>     <span class="c1">// A Float32-to-String dictionary</span>
<span class="kr">Boolean</span> <span class="nx">integerToBoolean</span><span class="p">[</span><span class="kr">Integer</span><span class="p">];</span>  <span class="c1">// An Integer-to-Boolean dictionary</span>
</pre></div>
</div>
<p>Dictionaries in KL have the following properties:</p>
<ul>
<li><p class="first">Dictionaries are <em class="dfn">share-on-assign</em>, meaning that when you assign one dictionary to another it does not copy the contents but rather copies a reference to the contents; any changes to one of the dictionaries changes the other as well.  This is sometimes referred to as a shallow copy (as opposed to a deep copy).  In order to obtain a deep copy of a dictionary, use the <code class="docutils literal"><span class="pre">clone()</span></code> method, described below.</p>
</li>
<li><p class="first">Dictionaries can be nested, and can be co-nested with array types.  For example:</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="kr">Integer</span> <span class="nx">b</span><span class="p">[</span><span class="kr">String</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// An String-to-Fixed-Length-Integer-Array dictionary</span>
<span class="kr">Boolean</span> <span class="nx">a</span><span class="p">[][</span><span class="kr">Integer</span><span class="p">];</span> <span class="c1">// A variable array of Integer-to-Boolean dictionaries</span>
</pre></div>
</div>
</li>
<li><p class="first">Dictionaries can contain at most <span class="math">\(2^32-1\)</span> key-value pairs.</p>
</li>
<li><p class="first">Dictionaries support the <code class="samp docutils literal"><span class="pre">has(</span><em><span class="pre">key</span></em><span class="pre">)</span></code> method that returns a <code class="code docutils literal"><span class="pre">Boolean</span></code> value indicating whether there is a value in the dictionary for the given key.</p>
</li>
<li><p class="first">Dictionaries support the <code class="samp docutils literal"><span class="pre">get(</span><em><span class="pre">key</span></em><span class="pre">)</span></code> method that returns the value associated with the given key.  If there is no value for the given key, an exception is thrown.</p>
</li>
<li><p class="first">Dictionaries support the <code class="samp docutils literal"><span class="pre">set(</span><em><span class="pre">key</span></em><span class="pre">,</span> <em><span class="pre">value</span></em><span class="pre">)</span></code> method that sets the value for the key, replacing the existing value if there is already a value for the key.</p>
</li>
<li><p class="first">Dictionaries support indexing using the <code class="samp docutils literal"><span class="pre">[</span><em><span class="pre">key</span></em><span class="pre">]</span></code> indexing operator.  When used as the target of an assignment or as an io parameter to a function (eg. <code class="samp docutils literal"><em><span class="pre">dict</span></em><span class="pre">[</span><em><span class="pre">key</span></em><span class="pre">]</span> <span class="pre">=</span> <em><span class="pre">value</span></em></code>), it is equivalent to using the <code class="samp docutils literal"><span class="pre">set(</span><em><span class="pre">key</span></em><span class="pre">,</span> <em><span class="pre">value</span></em><span class="pre">)</span></code> method.  When used as a read-only expression (eg. <code class="samp docutils literal"><em><span class="pre">value</span></em> <span class="pre">=</span> <em><span class="pre">dict</span></em><span class="pre">[</span><em><span class="pre">key</span></em><span class="pre">]</span></code>), it is equivalent to using the <code class="samp docutils literal"><span class="pre">get(</span><em><span class="pre">key</span></em><span class="pre">)</span></code> method.</p>
</li>
<li><p class="first">Dictionaries support the <code class="samp docutils literal"><span class="pre">get(</span><em><span class="pre">key</span></em><span class="pre">,</span> <em><span class="pre">defaultValue</span></em><span class="pre">)</span></code> method that returns the value associated with the given key, if it exists, or <code class="samp docutils literal"><em><span class="pre">defaultValue</span></em><span class="pre">`</span></code> if there is no value for the given key.</p>
</li>
<li><p class="first">Dictionaries support the <code class="samp docutils literal"><span class="pre">delete(</span><em><span class="pre">key</span></em><span class="pre">)</span></code> method that deletes the value for the given key.  If there is no value for the given key, nothing happens.</p>
</li>
<li><p class="first">Dictionaries support the <code class="docutils literal"><span class="pre">clone()</span></code> method which makes a deep copy of the dictionary.  The resulting copy is initially not shared with any other dictionaries.</p>
</li>
<li><p class="first">Dictionaries support the <code class="docutils literal"><span class="pre">clear()</span></code> method which removes all keys and values.</p>
</li>
<li><p class="first">Dictionaries can be iterated over using JavaScript-like <code class="docutils literal"><span class="pre">in</span></code> iteration:</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="kr">String</span> <span class="nx">dict</span><span class="p">[</span><span class="kr">String</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="nx">k</span> <span class="k">in</span> <span class="nx">dict</span><span class="p">)</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;dict[&quot;</span> <span class="o">+</span> <span class="nx">k</span> <span class="o">+</span> <span class="s2">&quot;] = &quot;</span> <span class="o">+</span> <span class="nx">dict</span><span class="p">[</span><span class="nx">k</span><span class="p">]);</span>
</pre></div>
</div>
<p>For improved performance, both the key and value can be made available through <code class="docutils literal"><span class="pre">in</span></code> iteration:</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="kr">String</span> <span class="nx">dict</span><span class="p">[</span><span class="kr">String</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="k">in</span> <span class="nx">dict</span><span class="p">)</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;dict[&quot;</span> <span class="o">+</span> <span class="nx">k</span> <span class="o">+</span> <span class="s2">&quot;] = &quot;</span> <span class="o">+</span> <span class="nx">v</span><span class="p">);</span>
</pre></div>
</div>
<p>In a dictionary iteration, the value can be assigned to if and only if the dictionary can be assigned to.  The key, on the other hand, cannot be assigned to.</p>
</li>
<li><p class="first">Insertion order (not sort order!) is the iteration order for dictionaries, just as for JavaScript objects:</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">String</span> <span class="nx">numbers</span><span class="p">[</span><span class="kr">Integer</span><span class="p">];</span>
  <span class="nx">numbers</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;three&quot;</span><span class="p">;</span>
  <span class="nx">numbers</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;two&quot;</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">numbers</span><span class="p">);</span>
  <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;one&quot;</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">numbers</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">{3:&quot;three&quot;,2:&quot;two&quot;}</span>
<span class="cm">{3:&quot;three&quot;,2:&quot;two&quot;,1:&quot;one&quot;}</span>

<span class="cm">*/</span>
</pre></div>
</div>
</li>
</ul>
<p>The following is an example use of dictionaries:</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** Example: Dictionaries</span>
<span class="cm">*/</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">Float32</span> <span class="nx">a</span><span class="p">[</span><span class="kr">String</span><span class="p">];</span>
  <span class="nx">a</span><span class="p">[</span><span class="s1">&#39;pi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
  <span class="nx">a</span><span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.71</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;a is:&quot;</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="k">in</span> <span class="nx">a</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;a[&#39;&quot;</span> <span class="o">+</span> <span class="nx">k</span> <span class="o">+</span> <span class="s2">&quot;&#39;] = &quot;</span> <span class="o">+</span> <span class="nx">v</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">a</span><span class="p">.</span><span class="nx">delete</span><span class="p">(</span><span class="s1">&#39;pi&#39;</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;a is now:&quot;</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="k">in</span> <span class="nx">a</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;a[&#39;&quot;</span> <span class="o">+</span> <span class="nx">k</span> <span class="o">+</span> <span class="s2">&quot;&#39;] = &quot;</span> <span class="o">+</span> <span class="nx">v</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">a is:</span>
<span class="cm">a[&#39;pi&#39;] = +3.14</span>
<span class="cm">a[&#39;e&#39;] = +2.71</span>
<span class="cm">a is now:</span>
<span class="cm">a[&#39;e&#39;] = +2.71</span>

<span class="cm">*/</span>
</pre></div>
</div>
<div class="section" id="dictionaries-using-custom-key-types">
<span id="klpg-dictionaries-custom-key-types"></span><span id="index-21"></span><h4>Dictionaries Using Custom Key Types<a class="headerlink" href="#dictionaries-using-custom-key-types" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>You can use a custom <code class="samp docutils literal"><span class="pre">struct</span></code> as a key type for a dictionary by implementing a <code class="samp docutils literal"><span class="pre">.hash</span></code> method for the type as well as a <code class="samp docutils literal"><span class="pre">==</span></code> operator:</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** Example: Dictionary with Custom Key Type</span>
<span class="cm">*/</span>

<span class="kr">struct</span> <span class="nx">S</span> <span class="p">{</span>
  <span class="kr">UInt32</span> <span class="nx">n</span><span class="p">;</span>
  <span class="kr">Float32</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">};</span>


<span class="kd">function</span> <span class="nx">S</span><span class="p">(</span><span class="kr">UInt32</span> <span class="nx">n</span><span class="p">,</span> <span class="kr">Float32</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">n</span> <span class="o">=</span> <span class="nx">n</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="kr">Boolean</span> <span class="o">==</span><span class="p">(</span><span class="nx">S</span> <span class="nx">lhs</span><span class="p">,</span> <span class="nx">S</span> <span class="nx">rhs</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">lhs</span><span class="p">.</span><span class="nx">n</span> <span class="o">==</span> <span class="nx">rhs</span><span class="p">.</span><span class="nx">n</span> <span class="o">&amp;&amp;</span> <span class="nx">lhs</span><span class="p">.</span><span class="nx">x</span> <span class="o">==</span> <span class="nx">rhs</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="kr">UInt32</span> <span class="nx">S</span><span class="p">.</span><span class="nx">hash</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">n</span><span class="p">.</span><span class="nx">hash</span><span class="p">()</span> <span class="o">^</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">hash</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">String</span> <span class="nx">d</span><span class="p">[</span><span class="nx">S</span><span class="p">];</span>
  <span class="nx">d</span><span class="p">[</span><span class="nx">S</span><span class="p">(</span><span class="mi">56</span><span class="p">,</span><span class="mf">2.4</span><span class="p">)]</span> <span class="o">=</span> <span class="s2">&quot;one&quot;</span><span class="p">;</span>
  <span class="nx">d</span><span class="p">[</span><span class="nx">S</span><span class="p">(</span><span class="mi">78</span><span class="p">,</span><span class="o">-</span><span class="mf">1.2</span><span class="p">)]</span> <span class="o">=</span> <span class="s2">&quot;two&quot;</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">d</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">{{n:56,x:+2.4}:&quot;one&quot;,{n:78,x:-1.2}:&quot;two&quot;}</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="map-reduce-types">
<span id="index-22"></span><h3>Map-Reduce Types<a class="headerlink" href="#map-reduce-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>There are two additional derived types used exclusively for work within Fabric&#8217;s map-reduce framework, namely:</p>
<ul class="simple">
<li><code class="samp docutils literal"><span class="pre">ValueProducer&lt;</span><em><span class="pre">Type</span></em><span class="pre">&gt;</span></code></li>
<li><code class="samp docutils literal"><span class="pre">ArrayProducer&lt;</span><em><span class="pre">Type</span></em><span class="pre">&gt;</span></code></li>
</ul>
<p>For more information, see <a class="reference internal" href="map-reduce.html#map-reduce"><span>Map-Reduce</span></a>.</p>
</div>
</div>
<div class="section" id="implicit-type-casting-rules-in-kl">
<span id="index-23"></span><h2>Implicit Type Casting Rules in KL<a class="headerlink" href="#implicit-type-casting-rules-in-kl" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>When a function or method is called in KL, but the types of the arguments do not exactly match the types of the parameters for any polymorphic version of the function or method, KL will attempt to find the best match using implicit casts.  The best match is chosen as follows:</p>
<ul class="simple">
<li>The number of arguments must exactly match the number of parameters.  Therefore, if there is a mismatch, the polymorphic version is not considered.  For example, if the function call <code class="code docutils literal"><span class="pre">foo(14,</span> <span class="pre">23)</span></code> is made and there is a function <code class="code docutils literal"><span class="pre">foo(Integer)</span></code> available, it will not be considered because it only takes one parameter but two arguments have been given.</li>
<li>If the number of parameters matches the number of arguments, the &#8220;cost&#8221; of the call is computed as the maximum &#8220;cost&#8221; for each argument.  The cost for each argument is computed as follows:<ul>
<li>The cost is zero if there is an exact type match</li>
<li>The cost is very low for inheritance, ie. if the parameter type is <code class="code docutils literal"><span class="pre">A</span></code>, the argument type is <code class="code docutils literal"><span class="pre">B</span></code>, and <code class="code docutils literal"><span class="pre">B</span></code> inherits from <code class="code docutils literal"><span class="pre">A</span></code></li>
<li>Otherwise, the cost is computed on a per-type basis, and are what would generally be expected.  For instance, casts from smaller integer values to larger ones (eg. <code class="code docutils literal"><span class="pre">UInt16</span></code> to <code class="code docutils literal"><span class="pre">UInt32</span></code>) are very low cost, whereas expensive operations (conversions to strings, numerical conversions that might lose precision) have a high cost.</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="type-aliases">
<h2>Type Aliases<a class="headerlink" href="#type-aliases" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The <code class="docutils literal"><span class="pre">alias</span></code> statement can be used to alias a type to make code more readable.  Its syntax is the same as a variable declaration:</p>
<div class="highlight-python"><div class="highlight"><pre>alias Integer Int32;        // Int32 is now an alias for Integer
alias Float32 float;        // float is now an alias for Float32
alias Float32 Mat22[2][2];  // Mat22 is now an alias for Float32[2][2], ie. a size-2-array-of-size-2-arrays-of-Float32
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">alias</span></code> statements must appear within the global scope of a KL program.</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** Example: Type Aliases</span>
<span class="cm">*/</span>

<span class="nx">alias</span> <span class="kr">Float32</span> <span class="nx">Mat22</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Mat22</span> <span class="nx">mat22</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="nx">mat22</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">[[+0.0,+0.0],[+0.0,+0.0]]</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="the-data-type-and-the-data-and-datasize-methods">
<span id="index-24"></span><h2>The <code class="docutils literal"><span class="pre">Data</span></code> Type and the <code class="docutils literal"><span class="pre">data</span></code> and <code class="docutils literal"><span class="pre">dataSize</span></code> Methods<a class="headerlink" href="#the-data-type-and-the-data-and-datasize-methods" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>When interfacing with external libraries such as OpenGL, it is sometimes necessary to get direct access to the data underlying a value.  An example is a library call that takes a pointer to data.  KL itself has no notion of pointers; instead, KL has the concept of the <code class="docutils literal"><span class="pre">Data</span></code> type whose value is a pointer to data which can be passed to an external library call.</p>
<p>Most values in KL have a built-in method called <code class="docutils literal"><span class="pre">data</span></code> that returns a value of type <code class="docutils literal"><span class="pre">Data</span></code>, and a built-in method called <code class="docutils literal"><span class="pre">dataSize</span></code> that returns a value of type <code class="docutils literal"><span class="pre">Size</span></code>.  The value returned by the <code class="docutils literal"><span class="pre">data</span></code> method is a pointer to the data underlying the value, and the value returned by the <code class="docutils literal"><span class="pre">dataSize</span></code> method is the number of bytes the value occupies in memory.  The only values which do not support the <code class="docutils literal"><span class="pre">data</span></code> and <code class="docutils literal"><span class="pre">dataSize</span></code> methods are dictionaries as well as other derived types that do not lay out their elements or members contiguously in memory:</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** Example: Valid and Invalid Use of .data() and .dataSize()</span>
<span class="cm">*/</span>

<span class="kr">Integer</span> <span class="nx">integers</span><span class="p">[];</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">integers</span><span class="p">.</span><span class="nx">data</span><span class="p">());</span>  <span class="c1">// OK: integers are contiguous in memory</span>
<span class="kr">String</span> <span class="nx">strings</span><span class="p">[];</span>
<span class="nb">report</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">data</span><span class="p">());</span>   <span class="c1">// ERROR: string data is not contiguous in memory</span>
</pre></div>
</div>
<p>Unlike pointers in C and C++, the values returned by <code class="docutils literal"><span class="pre">data</span></code> methods cannot be inspected or used in any expressions; the only thing which can be done is a cast to <code class="code docutils literal"><span class="pre">Boolean</span></code>, which will be <code class="code docutils literal"><span class="pre">true</span></code> if and only if the <code class="docutils literal"><span class="pre">Data</span></code> value points to a value whose size is greater than zero.  However, these <code class="docutils literal"><span class="pre">Data</span></code> values can be passed directly to external library functions provided by Fabric itself or Fabric extensions, where they are used as pointers to data in memory.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">For values of type <code class="docutils literal"><span class="pre">String</span></code>, the value returned by <code class="docutils literal"><span class="pre">dataSize</span></code> includes a null terminator that is automatically appended to the string by Fabric; this is so that the string data can be directly used in C library calls as a regular C string.  If you want to pass the number of characters in the string, pass <code class="docutils literal"><span class="pre">string.length</span></code> instead.</p>
</div>
<p>Example of <code class="docutils literal"><span class="pre">Data</span></code> values and the <code class="docutils literal"><span class="pre">data</span></code> and <code class="docutils literal"><span class="pre">dataSize</span></code> methods:</p>
<div class="highlight-kl"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** Example: .data() and .dataSize()</span>
<span class="cm">*/</span>

<span class="kd">operator</span> <span class="nx">entry</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">String</span> <span class="nx">s</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;s = &#39;&quot;</span> <span class="o">+</span> <span class="nx">s</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;s.data() = &quot;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">data</span><span class="p">());</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;Boolean(s.data()) = &quot;</span> <span class="o">+</span> <span class="kr">Boolean</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">data</span><span class="p">()));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;s.dataSize() = &quot;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">dataSize</span><span class="p">());</span>
  <span class="nx">s</span> <span class="o">=</span> <span class="s2">&quot;Hello&quot;</span><span class="p">;</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;s = &#39;&quot;</span> <span class="o">+</span> <span class="nx">s</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">);</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;s.data() = &quot;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">data</span><span class="p">());</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;Boolean(s.data()) = &quot;</span> <span class="o">+</span> <span class="kr">Boolean</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">data</span><span class="p">()));</span>
  <span class="nb">report</span><span class="p">(</span><span class="s2">&quot;s.dataSize() = &quot;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">dataSize</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Output:</span>

<span class="cm">s = &#39;&#39;</span>
<span class="cm">s.data() = &lt;Opaque&gt;</span>
<span class="cm">Boolean(s.data()) = true</span>
<span class="cm">s.dataSize() = 1</span>
<span class="cm">s = &#39;Hello&#39;</span>
<span class="cm">s.data() = &lt;Opaque&gt;</span>
<span class="cm">Boolean(s.data()) = true</span>
<span class="cm">s.dataSize() = 6</span>

<span class="cm">*/</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/FE_logo_211_37.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">KLの型システム</a><ul>
<li><a class="reference internal" href="#base-types">基本型（Base Types）</a><ul>
<li><a class="reference internal" href="#the-boolean-type">論理型（ <code class="code docutils literal"><span class="pre">Boolean</span></code> Type）</a></li>
<li><a class="reference internal" href="#integer-types">整数型（Integer Types）</a><ul>
<li><a class="reference internal" href="#integer-atomic-methods">整数型のアトミックメソッド</a></li>
</ul>
</li>
<li><a class="reference internal" href="#floating-point-types">浮動小数点数型（Floating-Point Types）</a></li>
<li><a class="reference internal" href="#the-string-type">文字列型（<code class="docutils literal"><span class="pre">String</span></code> Type）</a></li>
</ul>
</li>
<li><a class="reference internal" href="#derived-types">派生型（Derived Types）</a><ul>
<li><a class="reference internal" href="#structures">構造体（Structures）</a><ul>
<li><a class="reference internal" href="#structure-member-alignment">構造体メンバのアライメント</a></li>
<li><a class="reference internal" href="#structure-inheritance">構造体の継承</a></li>
</ul>
</li>
<li><a class="reference internal" href="#objects">オブジェクト（Objects）</a><ul>
<li><a class="reference internal" href="#the-object-clone-method">Object <code class="docutils literal"><span class="pre">clone()</span></code> メソッド</a></li>
<li><a class="reference internal" href="#object-inheritance">オブジェクトの継承</a></li>
</ul>
</li>
<li><a class="reference internal" href="#interfaces">インタフェース（Interfaces）</a><ul>
<li><a class="reference internal" href="#the-object-interface"><code class="code docutils literal"><span class="pre">Object</span></code> インタフェース</a></li>
<li><a class="reference internal" href="#structure-object-and-interface-access-contols">構造体、オブジェクト、インタフェースでのアクセス制御</a></li>
<li><a class="reference internal" href="#interfaces-and-inheritance">インタフェースと継承</a></li>
<li><a class="reference internal" href="#forward-declaration-of-objects-and-interfaces">オブジェクト、インタフェースの前方宣言</a></li>
<li><a class="reference internal" href="#unowned-object-and-interface-references">未所有オブジェクト、インタフェースへの参照</a></li>
<li><a class="reference internal" href="#the-type-type"><code class="code docutils literal"><span class="pre">Type</span></code> 型</a></li>
<li><a class="reference internal" href="#objects-versus-structures">オブジェクト vs 構造体</a></li>
</ul>
</li>
<li><a class="reference internal" href="#arrays">配列</a><ul>
<li><a class="reference internal" href="#variable-size-arrays">可変長配列（Variable-Size Arrays）</a></li>
<li><a class="reference internal" href="#fixed-size-arrays">固定長配列（Fixed-Size Arrays）</a></li>
<li><a class="reference internal" href="#external-arrays">External Arrays</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dictionaries">Dictionaries</a><ul>
<li><a class="reference internal" href="#dictionaries-using-custom-key-types">Dictionaries Using Custom Key Types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#map-reduce-types">Map-Reduce Types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implicit-type-casting-rules-in-kl">Implicit Type Casting Rules in KL</a></li>
<li><a class="reference internal" href="#type-aliases">Type Aliases</a></li>
<li><a class="reference internal" href="#the-data-type-and-the-data-and-datasize-methods">The <code class="docutils literal"><span class="pre">Data</span></code> Type and the <code class="docutils literal"><span class="pre">data</span></code> and <code class="docutils literal"><span class="pre">dataSize</span></code> Methods</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="syntax.html"
                        title="前の章へ">KLの文法</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="globals.html"
                        title="次の章へ">Functions and Other Global Declarations</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/KLProgrammingGuide/types.txt"
            rel="nofollow">ソースコードを表示</a></li>
    <li><a href="http://docs.fabric-engine.com/FabricEngine/2.0.0/HTML/KLProgrammingGuide/types.html"
              rel="nofollow">原文公式ページへ移動</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="globals.html" title="Functions and Other Global Declarations"
             >次へ</a> |</li>
        <li class="right" >
          <a href="syntax.html" title="KLの文法"
             >前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Fabric Engine 2.0.0 Unofficial Documentation (ja)</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >KL プログラミングガイド</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2010-2015 Fabric Software Inc.
      このドキュメントは <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1 で生成しました。
    </div>
  </body>
</html>